<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Squid搭建代理服务器]]></title>
      <url>%2F2017%2F03%2F18%2FSquid-Proxy%2F</url>
      <content type="text"><![CDATA[Squid搭建代理服务器使用爬虫经常遭到IP被封，网上免费代理经常也不可用，个人写爬虫购买代理没必要，如果有自己的阿里云服务器，则可以使用Squid搭建代理服务器，自己搭建的代理IP稳定可靠，以下将搭建过程记录如下。 安装环境为Centos6.5 first install squid1$ sudo yum install squid then install httpd-tools1$ sudo yum install httpd-tools then create a file to store passwords in it and change the ownership of it so Squid can access12$ sudo touch /etc/squid/passwd$ sudo chown squid /etc/squid/passwd then set password for jack1234$ sudo htpasswd -d /etc/squid/passwd jack New password: Re-type new password: Adding password for user jack test password is ok123$ /usr/lib64/squid/ncsa_auth /etc/squid/passwdjack yourpasswordOK then in /etc/squid/squid.conf and add following lines to the top of file. and save it12345678auth_param basic program /usr/lib64/squid/ncsa_auth /etc/squid/passwdauth_param basic children 5auth_param basic realm Squid proxy-caching web serverauth_param basic credentialsttl 2 hoursauth_param basic casesensitive offacl ncsa_users proxy_auth REQUIREDhttp_access allow ncsa_users last restart squid12$ sudo service squid restart$ chkconfig squid on Remember to restart the Squid service after deleting the user line in the file1jack:ehHDxD10B5KAu Anonymizing Traffic123456789101112131415161718192021222324252627282930forwarded_for offrequest_header_access Allow allow allrequest_header_access Authorization allow allrequest_header_access WWW-Authenticate allow allrequest_header_access Proxy-Authorization allow allrequest_header_access Proxy-Authenticate allow allrequest_header_access Cache-Control allow allrequest_header_access Content-Encoding allow allrequest_header_access Content-Length allow allrequest_header_access Content-Type allow allrequest_header_access Date allow allrequest_header_access Expires allow allrequest_header_access Host allow allrequest_header_access If-Modified-Since allow allrequest_header_access Last-Modified allow allrequest_header_access Location allow allrequest_header_access Pragma allow allrequest_header_access Accept allow allrequest_header_access Accept-Charset allow allrequest_header_access Accept-Encoding allow allrequest_header_access Accept-Language allow allrequest_header_access Content-Language allow allrequest_header_access Mime-Version allow allrequest_header_access Retry-After allow allrequest_header_access Title allow allrequest_header_access Connection allow allrequest_header_access Proxy-Connection allow allrequest_header_access User-Agent allow allrequest_header_access Cookie allow allrequest_header_access All deny all 1234567891011121314#### -----------------------------------------------------------# 配置文件 /etc/squid/squid.conf 可修改监听端口http_access deny all 修改成 http_access allow all# 日志目录 /var/log/squid 实时日志$ tail -f /var/log/squid/ access.log#### ------------------------------------------------------------打开浏览器设置代理，如果不成功，关闭防火墙，增加IP端口试试。$ /etc/init.d/iptables stop$ iptables -F$ netstat -punlt$ vim /etc/sysconfig/iptables-A INPUT -m state --state NEW -m tcp -p tcp --dport 3128 -j ACCEPT#### -------------------------------------------------------------测试 curl -I -s -x http://代理服务IP:3128 www.baidu.com 参考资料: https://arashmilani.com/post?id=49 http://www.cnblogs.com/apanly/p/5165294.html http://blog.csdn.net/skylinethj/article/details/43837277 https://github.com/onlyfu/Blog/blob/master/Chrome/%E4%B8%80%E8%B5%B7%E6%9D%A5%E5%81%9Achrome%E6%89%A9%E5%B1%95%E3%80%8A%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8localStorage%E3%80%8B.md https://github.com/onlyfu/Blog/blob/master/Other/Vim%EF%BC%8C%E6%9E%81%E7%AE%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%8C%E8%AE%A9%E4%BD%A0%E7%9E%AC%E9%97%B4%E8%84%B1%E7%A6%BB%E9%94%AE%E9%BC%A0%E5%88%87%E6%8D%A2%E7%9A%84%E7%97%9B%E8%8B%A6.md]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring-boot设置contextPath]]></title>
      <url>%2F2017%2F02%2F23%2Fspring%20boot%20%E8%AE%BE%E7%BD%AEcontextPath%2F</url>
      <content type="text"><![CDATA[spring boot 设置contextPath方法一 、velocity 配置123456789@Bean(name = "velocityViewResolver")public VelocityLayoutViewResolver velocityViewResolver(VelocityProperties properties) &#123; VelocityLayoutViewResolver resolver = new VelocityLayoutViewResolver(); properties.applyToViewResolver(resolver); resolver.setLayoutUrl("common/main_layout.vm"); resolver.setRequestContextAttribute("rc"); return resolver;&#125;vm页面中获取 $!rc.contextPath 即可 方法二、springMacroRequestContext内置对象12$!&#123;springMacroRequestContext.contextPath&#125;可以直接获取到contextPath，不用任何设置]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring boot 配置https|ssl]]></title>
      <url>%2F2016%2F11%2F04%2Fspring%20boot%20%E9%85%8D%E7%BD%AEhttps%7Cssl%2F</url>
      <content type="text"><![CDATA[spring boot 配置https|ssl配置支持httpsapplication.properties 需要生成sample.jks，放在classpath下 参考spring-boot-sample-tomcat-ssl 12345#tomcatserver.port = 8443server.ssl.key-store = classpath:sample.jksserver.ssl.key-store-password = secretserver.ssl.key-password = password 此时已可以使用https://localhost:8443 配置同时支持 http参考tomcat多连接器配置 12345678910111213141516171819@Beanpublic Integer port() &#123; return 8080; //return SocketUtils.findAvailableTcpPort();&#125;@Beanpublic EmbeddedServletContainerFactory servletContainer() &#123; TomcatEmbeddedServletContainerFactory tomcat = new TomcatEmbeddedServletContainerFactory(); tomcat.addAdditionalTomcatConnectors(createStandardConnector()); return tomcat;&#125;private Connector createStandardConnector() &#123; Connector connector = new Connector("org.apache.coyote.http11.Http11NioProtocol"); connector.setPort(port()); return connector;&#125; 此时可以使用http://localhost:8080 如果支持http重定向到https123456789101112131415161718192021222324252627282930 @Value("$&#123;server.port&#125;") private int port;@Bean public EmbeddedServletContainerFactory servletContainer() &#123; TomcatEmbeddedServletContainerFactory tomcat = new TomcatEmbeddedServletContainerFactory() &#123; @Override protected void postProcessContext(Context context) &#123; SecurityConstraint securityConstraint = new SecurityConstraint(); securityConstraint.setUserConstraint("CONFIDENTIAL"); SecurityCollection collection = new SecurityCollection(); collection.addPattern("/*"); securityConstraint.addCollection(collection); context.addConstraint(securityConstraint); &#125; &#125;; tomcat.addAdditionalTomcatConnectors(initiateHttpConnector()); return tomcat; &#125; private Connector initiateHttpConnector() &#123; Connector connector = new Connector("org.apache.coyote.http11.Http11NioProtocol"); connector.setScheme("http"); connector.setPort(8080); connector.setSecure(false); connector.setRedirectPort(port); return connector; &#125; 此时使用http://localhost:8080会自动重定向到https://localhost:8443]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[卸载jdk]]></title>
      <url>%2F2016%2F08%2F08%2F%E5%8D%B8%E8%BD%BDjdk%2F</url>
      <content type="text"><![CDATA[卸载jdk1234567891011121314151617卸载jdk1.6 1、卸载系统自带的jdk版本： 查看自带的jdk： #rpm -qa|grep gcj 看到如下信息： libgcj-4.1.2-44.el5 java-1.4.2-gcj-compat-1.4.2.0-40jpp.115 使用rpm -e --nodeps 命令删除上面查找的内容： #rpm -e –nodeps java-1.4.2-gcj-compat-1.4.2.0-40jpp.115 2、卸载rpm安装的jkd版本 查看安装的jdk： #rpm -qa|grep jdk 看到如下信息： jdk-1.6.0_22-fcs 卸载： #rpm -e --nodeps jdk-1.6.0_22-fcs]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java面试摘要]]></title>
      <url>%2F2016%2F08%2F08%2Fjava%E9%9D%A2%E8%AF%95%E6%91%98%E8%A6%81%2F</url>
      <content type="text"><![CDATA[java面试摘要1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172181、spring的缓存,mybatis缓存a、基于注解的方式 三种注解b、mybatis分为一级session和二级缓存mapperc、采用LRU算法（近期最少使用） http://www.iteye.com/topic/1112327/ 对缓存并发同步采用jdk的ReadWriteLock 读写锁源码：mapper调用、代理mapper调用、mapper的方法、sqlsession、缓存（二级没有到一级，一级没有到数据库搜）2、介绍下dubbo。A服务调用B服务，B服务又调用C服务,这种情况怎么办client一个线程调用远程接口，生成一个唯一的ID（比如一段随机字符串，UUID等），Dubbo是使用AtomicLong从0开始累计数字的将打包的方法调用信息（如调用的接口名称，方法名称，参数值列表等），和处理结果的回调对象callback，全部封装在一起，组成一个对象object向专门存放调用信息的全局ConcurrentHashMap里面put(ID, object)将ID和打包的方法调用信息封装成一对象connRequest，使用IoSession.write(connRequest)异步发送出去当前线程再使用callback的get()方法试图获取远程返回的结果，在get()内部，则使用synchronized获取回调对 象callback的锁， 再先检测是否已经获取到结果，如果没有，然后调用callback的wait()方法，释放callback上的锁，让当前线程处于等待状态。服务端接收到请求并处理后，将结果（此结果中包含了前面的ID，即回传）发送给客户端，客户端socket连接上专门监听消息的线程收到 消息，分析结果，取到ID，再从前面的ConcurrentHashMap里面get(ID)，从而找到callback，将方法调用结果设置到 callback对象里。监听线程接着使用synchronized获取回调对象callback的锁（因为前面调用过wait()，那个线程已释放 callback的锁了），再notifyAll()，唤醒前面处于等待状态的线程继续执行（callback的get()方法继续执行就能拿到调用结果 了），至此，整个过程结束。循环依赖： check=&quot;false&quot; 来不检查依赖3、JVM监控工具有哪些，区别又是什么（如能追上各个命令的使用监控，显得更好）,如何调优的（就那么几个内存参数和GC参数什么时候配置什么样的）?如何定位问题的？（就说各种命令，gc日志，快照，监控工具）1、jstack 可以定位到具体的线程堆栈，定位cpu冲高 结合top2、jmap查看堆内存使用情况3、jstat统计堆的使用情况4、vivalueVM MAT4、GC日志 PrintGCDetails 每次GC记录日志4、使用过Solr?说说（有面试特意想听从luence发展而来的可独立部署）5、用过哪些MQ,各个MQ的区别不同点在哪(阿里还问了协议；采用哪种语言开发的也说说比较好，因为一些面试为了好跟踪问题确实考虑了这一方面)，总之，多说为益，再就是apache新一代推出的MQ：apollo说说完全是加分项阿里面试者也不知道。6、根据你做过的东西，让你说说某一功能或者模块7、java8了解过吗（阿里问的，时间API,集合的处理，lambda怎么用的说说,函数式编程，很多集合底层代码都有变动能详细说出来加分如hashMap，集合底层代码变动网上是没有的别查了，看JDK7,8,9源码就行）（本人建议最好把JDK7，8，将要推出的9各种新特点熟记并全部动手编写下，9暂时不能编写呢），JDK9特性说上绝逼加分，他也很可能不知道，再就是CMS+新生代并行收集器JAVA8不建议使用了（很少有面试官知道），java9淘汰掉了还有永生带被元空间代替即使阿里他也不知道绝逼加分。8、说说memcached(直接上原理，说分配的过程，再说注意点优缺点，和哈希一致算法能联系起来更好，前提一致算法要理解要能用代码实现，否则面试着好追问，你要不懂到起反作用了)9、有几种锁，各个区别，多说有益，多说上底层的更好，阿里还问了原理10、sleep和await()的区别（补充上condition给自己加分）condition实例被绑定到一个Lock对象上,通过newCondition()来达到这个目的. condition提供三个方法来达到同步；await(),类似wait() sginal() 类似notifysignalAll()类似notifyAll11、线程池说说几种（最好搞懂源码里的原理起码用的哪些队列能说说各自的使用场景说说都是加分的地方，有什么注意点，什么keepalivatime其他的什么的细的问题，多多益善）12、哪些锁，不同的地方在哪（说的越多越详细越深越好）13、Threadlocal，上来说原理，再举个例子用用哪些情况为益14、线程池线程池如何解决死锁问题如何诊断，一定要说上具体命令如何定位阿里还特意追问的（从避免这种情况出发说如定时锁，锁粒度等再谈一些监控工具和命令，诊断啥的都会是加分）15、常见的序列化方式（面试官想让你说hession，多说为益）16、mysql与mongoDB如何选型，什么时候用谁17、A,B两个线程同时启动，但让A结束后B在结束，如何实现（多种，多说为益，他想问join,其他很多方式一些面试官都不知道绝对加分）18、redis中wacth之后，之后有事务提交未执行，返回信息吗，返回什么19、memcached和redis的区别，很多，把重点说出来，及各自优缺点，从原理上分析对比必是加分项可能redis原理他不懂的，几乎家家公司必问20、mongoDB的干什么的（在说说内存文件映射引擎，持久化的2个过程必是加分项）21、python了解吗，主要用来做什么，实现爬虫能实现吗（爬虫技术知道的话多扯些有益而无害）22、JVM的各个带说说（说的越详细越好各个参数都说上什么情况下怎么设置参数更好，和GC结合起来必加分），JVM的GC为什么选择分带收集（最好各个算法说上，为什么这个带使用这个，和G1的各个方面扯上必装逼成功加分因为几乎他也不懂，因为G1也是采用化整为0的这种分开治理的思想）23、ngnix,正向代理，反向代理,阿里特意问了ngnix原理和apache的区别以及出个问题故意让你答和lua脚本结合，然后会继续问你会不会写？ngnix与tomcat的区别24、zookeeper干什么的说说（多说为益扯上补充上如何实现分布式锁，同步流程，watcher机制代码流程选举算法绝对装逼99分），分布式锁怎么实现（额外说上尽可能避免分布式锁怎么避免为什么避免绝逼加分）。阿里直接让说了选举算法（描述大体过程和关键点即可不需要太详细了）25、redis两种持久化方式（过程，优缺点最好说上）26、复合索引的使用，什么时候走什么时候不走，举例27、如何实现session共享28、多线程下如何实现唯一ID（多种技术，多说为益，越高大尚越好）29、js闭包30、说说我游览器输入www.baidu.com之后怎么一个数据传输过程，主要考网络模型31、7层模式都是那几个，有哪些协议，怎么传输的，丢包问题，粘包问题，楚楚街特意问的32、java里有哪些集合接口，这些集合的区别是什么，说的越多越深越好，再就是LinkedList的扩容机制，hashmap的扩容机制，注意JDK6,7,8好像都有变化说上绝逼加分项因为他也不知道也没注意过只是停留在JDK6上那个机制。33、java有几种基本类型，挑出一种多大字节，取值范围，一个汉字多大空间占（注意根据不同编码说而且不同的汉字如复杂汉字就特殊也是加分点我是根据UTF-8，还追问了GBK）34、sql执行的过程说说（当时我只说了是9个过程，但具体记不清了，而且会有几个过程缓存住）35、什么是笛卡尔积，一个SQL语句where后边有很多and和组后group,limit怎么执行的具体说说36、设计模式你熟悉哪些，然后挑出几个来说说具体怎么设计（最好能画类图，有6大关系搞懂，扩展说上都是加分项，再想加分，就说对某个模式如单例有很多种最牛逼的一种是哪个牛逼的面试官有时也不知道）37、说说mybatis的原理，如果让你设计持久层，你会怎么设计（本人从扩展、灵活、性能几方面切入的）38、让你画架构，各种负载集群的那种，特意问如果没有f5怎么着39、秒杀中超卖问题有多种方式实现让说说（阿里那本书和一些博客中介绍的很多）40、各种GC算法一定要熟记整个过程一丝不挂的搞熟练，阿里让画画各个过程，很多都问为什么这么做，为什么分带收集（按我前边说的，把G1具体过程捎带扯上绝逼加分因为他们很少懂）41、一些算法递归，二叉树都要懂，经常性的会面试的差不多了最后问你些数据结构方面熟悉吗，自己要会园上。42、100阶乘几个零思考会快速回答上来（面试第一次完全卡住了，主要是否看真那么钻研问题，阿里的，其实想想也挺简单，只不过那种场景让你快速答出我是思维有点乱了）43、内存资源很有限，但是相同的操作不断的分配和释放内存，内存已经被这种频繁的操作被分配很多了，怎么优化（说实话，题目我也没真正搞懂说了下缓存区他说是一方面说其他的什么多线程看样子不是那样的，阿里的）44、很大的字符串文件，怎么统计某个字符串出现的频率（其实考你拆分思想用多线程去处理，具体怎么拆分阿里的人也只说用脚本说主要考你拆分的思想，说让JAVA API和Guava处理这种简短字符串情况的API绝对是加分的）45、Guava用过哪些API，具体说说46、JVM的各个带说说画画，说的越具体越好，结合上调优和GC，各个命令和参数配置绝逼加分，越细越好，细的他都不知道必加分（阿里的人具体还追问了参数怎么写辛亏我知道常见就那几个）47、倒水问题，5升和3升如何称出4升水，其他技术都回答的差不多最后问的逻辑题48、mysql中2个引擎的区别，几乎家家必问49、mysql中char与varchar的区别，什么情况下用char比较好，int(5)类型字段如果存的数据超出大小会怎么样50、悲观锁、悲观锁解释解释，还有脏读和什么读一堆挂读的概念问我怎么理解他们，醉了，还有事务ACID分别说说，什么叫原子性，什么叫一致性，事务的隔离级别哪几种51、redis的事务,watcher,当watcher事务提交失败会返回信息吗，返回什么信息52、连接池用过哪些，阿里特意问了druid的特点（特点好多，多说为益），为什么采用连接池53、dubbo的整个调用过程，让画画，就是那4个，服务端启动注册消费端订阅那个，RPC的过程最好能顺口说出加分项。还有问dubbo服务端和消费端都配置了那个生效？dubbo里的jetty干啥用的？54、zk除了做分布式锁和注册中心，还能用来干啥55、重载和重写的区别，越详细越好，说的越多越好56、接口和抽象类区别，越详细越好，及为什么需要抽象类57、时间片解释下，上下文切换解析下，什么情况下会影响上下文切换，怎么避免过多的上下文切换58、一个线程，从连接池里获取一个连接connection后，然后这个线程开辟了2个子线程，把这个connection传给它俩个，提交数据会有影响吗，为什么（现在想想自己解释的有点牵强，应该从事务的传播行为和级别入手，也可能其他，肯定面试官自己使用不当遇到的bug问题,如有合理解释的或者特意能做了实验的，一定要告诉大家一声）59、什么叫复制构造函数，构造函数的重载60、JVM的内存分配？（要熟记，越细越好）61、TCP的三次握手四次拜拜要熟记62、浮点类型为什么有时候不精确，详细说出来，怎么解决63、int类型在32位和64位有什么不同64、zk分布式锁具体怎么实现（58，美团的都问了，最好亲自用代码编写下，思路搞懂）65、给一个字符串类型的数字，不调用java直接转的API写一个方法转换出来（58的不知道那个技术老大想考啥思路就是转字符数组利用ASSII编码，问他弄这个干啥他也不说）66、给我几张表，写几个个SQL（我之前利用子查询，后来他说不利用子查询一条sql查出来，其实就是连接查询group，和count然后再利用统计的数过滤下，其中count(*)和count(1)和面试官争辩了起来，他也不确定后来就过了，美团的）67、写个单例模式（其他有很多种，我也知道他想考啥，但是想加分，写最好的2点兼顾的利用私有静态内部类，网上提到的很少，优化书中的，面试官认为我是错的让我确定下，后来给他讲通了）68、熟悉哪些设计模式（然后让你简单说说，58让写的代理，把各个类图之间的关系说清楚及接口的设计加分的）69、代理有几种？静态代理和动态代理有什么区别？什么情况下用什么具体说说？70、让我说下OOP里的单一原则的定义（他说这个定义非常重要，非要我说出定义），我拿出具体的设计实例说明哪些地方设计体现单一原则（他还是让说定义，美团的，醉了，定义我肯定没仔细推敲过，大家可以推敲下）71、JVM的内存分配，内存溢出，内出调优，GC调优，GC算法，G1收集器，还有参数常用参数名（美团的那个人一直让我说哪个具体参数名字，我说JVM虚拟机参数列表一查就知道了知道那是工具就行，我看他的样子可能也没记住，还是拿着笔记本查呢，醉了，最好几个常用的记住看样子也是有意而无害的我都记个大概的样子），如何调优如何具体优化举例子越细越好什么阀值具体到什么GC算法在什么情况下怎么设置他的什么样的参数越细越好，还有问题诊断，具体怎么定位，最好前提你说上基于java的哪个版本规范，哪个虚拟机，因为不同版本不同虚拟机肯定有所不同，能说出来必加分(呵呵，装的你多严谨，如装逼成功肯定加分)72、NIO与IO的区别，什么情况下用谁，具体说说例子73、dubbo支持几种协议，协议的区别，容错机制，什么情况用什么，RPC的过程，dubbo是如何实现负载均衡的（源码级别），负载均衡策略，改过监控的中心吗，如何优化调用，怎么部署，zk挂掉3个挂掉2个会怎么样，为什么，看过dubbo源码吗74、哈希一致算法具体描述下（最后自己用java实现下或理解了），为什么要用hash一致算法75、在CPU不考虑的情况下内存有限的情况下计算最大并发数大概多少（linux下有很多注意事项会约束给他说说他可能也想不到都是加分的，然后再让你不考虑这些因素怎么计算说说，也和系统位数有关，也有对应的计算公式）76、在内存不考虑，8核CPU，挂起时间（好像是单个线程执行任务时间）30ms，CPU满负载最大多少并发（其实他当时也没说清楚，后来追问下补充了响应时间1S）77、给你写出2个数组，在纸上写个方法查出相同的元素（想考细节，把大体写出来之后给他说明一些特殊情况的处理），继续追问如何优化这个方法（说说自己的见解，如相同元素很多的情况用什么瞎吹呗），最好把JDK,commons，guava的相关API说下再说名你的理由啥的都是加分的78、linux命令用过哪些，说的越高大尚越好，常用的肯定要说上79、乐观锁问题，一般不直接问，给你说个分布式场景（用时间戳版本号啥的解决）80、CAS知道吗，说说（多多益善，说上ABA问题必加分有时面试官也不知道，扯上volite和锁区别什么场景下用谁必加分）81、让画ER图，时序图82、一个类里几个静态方法和几个普通方法，几个静态方法里有几个加synchronized，普通方法里有几个也加synchronized，这4种方法组合情况各个情况下同一个实例在多个线程里用到时阻塞不阻塞问题83、tomcat里有几个端口的配置？同一个tomcat能同时配置2个端口吗？84、tomcat里如何禁止服务端自动创建session85、servlet和过滤器，监听器，servlet启动顺序是什么样的86、spring的核心配置文件名是什么，具体描述一下里边的重要的配置,spring和mybatis集成的后的配置文件又怎么配置，需要配置什么,spring和springMVC的区别87、mybatis的配置文件怎么组织的，如何配置88、spring的AOP和IOC具体描述下，干什么的，怎么实现解偶的，它们是底层通过什么实现的89、类加载有哪些，机制是什么，类初始化的时机（那4个）有哪些90、一个对象为null一定会被GC掉吗（肯定不会，至少有2个过程，给他描述下，越细越好，他可能也不知道，楚楚街问的）91、final static 和static初始化都是什么时候初始化的？92、静态代码块和普通代码块有什么区别，什么场景下使用93、shell脚本写过吗？（就一家问到了就简答追问了下开头的声明干啥的）94、看过哪些书籍，平常怎么学习这些知识的95、conncurrentHashMap和hashmap的区别（6,7,8可能都所不同，能说出来必加分他可能也没注意过，不说也没关系）96、mongoDB,redis分片，主从，有问到，问到了都是简单问问，一般都是自己补充上其他东西，最好都要清楚，加分的，也以防万一,redis持久化2种方式有哪些问到有，然后你追加一些注意事项97、平常你遇到的一些不规范性问题，能再优化的问题，具体说说例子98、ngnix具体怎么配置切换服务器和负载均衡策略，说说具体的配置地方99、那些并发工具就不说了，最好都知道干啥用的，问到也有但是很少不知道到问啥100、netty和mina到时有提到的，但是就是简单问问知道吗，用过吗这些问题，当然自己对它们越熟练越清除越好101、tomcat具体在哪配置连接池，能配置哪些信息102、java反射类的私有方法与普通方法相比，需要多处理什么？103、java中有哪些集合？这些集合有什么区别，arrayList和HashMap的扩容机制（集合说的越多越好，各个集合都有什么区别，什么场景下用什么，注意些什么，有些6，7，8有不同，能说出来更好）104、zk有哪几种类型的节点，又有哪些监听事件，具体说说？105、用过哪几种抓包工具？报文结构？106、如何中断一个线程？线程在那种状态才可以中断？分库分表原则，具体什么场景采用什么举例子，分布式事务问题，AIO，索引原理等还有很多问题没问到，不过如果熟练掌握以上知识，即使一些其他的不懂也会是瑕疵不影响整体印象，再结合下边几点作为补充，技术面试国内任何一家公司包括阿里都是没问题的，吹的有点大，只适合装逼人士，一本正经者吹毛求疵者勿看。如果你已面试，欢迎补充面试技术点，你我码农共同进步！1、Spring.mvc的优势，原理，流程2、Mybatis的原理优势3、集合里面那些对象的原理4、扩容原理，特别是map的底层5、Hashmap、Hashtable和cocurrentHashMap的区别，要讲出它们各自的实现原理才行，比如Hashmap的扩容机制、cocurrentHashMap的桶分割原理、多线程安全性。6、几种造线程池的方法，区别7、Rpc原理8、Nio和netty，常用的接口9、Redis和数据库的持久化的10、Memached过程和原理11、多线程时间复杂度12、Redis做队列的原理13、zk做订阅的原理，底层14、Juc里面的锁原理15、实现自己的hashmap16、treemap红黑树17、jvm调优18、jvm内存模型19、类加载器机制20、数据库索引21、数据破坏索引22、手写快排23、js闭包24、nio是否了解 阻塞之后通知机制是怎样的？25、Java 的序列化做什么用的 序列化id会出现哪些问题？26、 在Java中Executor和Executors的区别？27、 为什么使用Executor框架比使用应用创建和管理线程好？28、怎么通过linux命令去分析jvm里面那个线程阻塞了29、Java中用到的线程调度算法是什么？30、什么是多线程中的上下文切换？31、classloader结构，是否可以自己定义一个java.lang.String类，为什么？ 双亲代理机制。32、有没有做过jvm内存调优，如何做的，举例子，用过哪些工具？33、Java中的volatile关键是什么作用？怎样使用它？在Java中它跟synchronized方法有什么不同？34、面试官从简历里抽了一个较感兴趣的项目，让把项目简单介绍了下，针对项目问了几个技术问题35、 介绍Java中垃圾回收机制，程序员平时需要关注这个吗？为什么？请举例说明。36、数据库隔离级别介绍、举例说明。37、override和overload的区别。38、求二叉树的最大距离（即相距最远的两个叶子节点），写代码。39、 两个栈实现一个队列，写代码。40、 你觉得你的优势是什么？有什么技术薄弱点吗？41、数据库sql调优，慢sql定位42、索引有哪几种，区别，使用场景43、mysql引擎，哪几种，区别使用场景NIO原理，内存模型，GC,锁机制传统IT外企干了8年，两年前转互联网的，面的和被面的都不少。这几天项目空档期，闲的蛋疼，随手写的， 不喜勿拍。1. 算法基础写java的基本上都是做应用系统的，用到算法的机会几乎没有，所以一般不会考。但是如果工作年限比较长，保不齐面试官怀疑你的编程能力，故意要考考，所以快排、堆排、逆转链表、遍历二叉树之类的基础还是复习复习吧。如果面的是bat核心部门，担心碰见装逼人士的话，也可以提前复习下《编程之美》之类的。2. java基础hashmap面试官最喜欢考，一定要搞明白原理。treemap知道就可以，应该没人闲的蛋疼考红黑树。threadlocal面试官也喜欢考，要搞明白原理反射、动态代理、ioc、aop复习下吧，几乎必考nio、aio几乎都会问，抽空写写例程，知道netty minaclass loader: 知道双亲委派，如果知道tomcat、jetty class loader异同更佳3. gcgc很多面试官都喜欢考面试前背熟各种gc算法的区别，理解原理。G1很多面试官自己都不明白，没时间就不用管。4. 高并发传统IT一般接触不到高并发，不过没关系按下面说的做，应付面试问题不大把java.util.concurrent下面所有的包和类通读一遍，理解原理、记住核心代码、写例程，网上有很多concurrent相关类原理解析的文章，对着文章看源代码理解起来问题不大。有些类代码很复杂比如aqs，看不明白就算了，也不用太花功夫，记住原理即可，因为大部分面试官也不明白。一定要写例程，例程最好跟你的业务能扯上一点点关系，这样面试的时候就是你实际项目里面的代码了。面试官喜欢考的类有：ConcurrentHashMap、读写锁、Condition、线程池、Barrier、CountDownLatch、Callable、BlockingQueue5. hdfs和mr传统IT一般也接触不到，如果不想准备就算了，如果想准备的话，就在自己的开发机上撘3个linux虚机， 按照网上的教程自己一步一步撘一个hadoop环境出来，然后找几个实际业务中生成出来的log，写几个mr程序处理一下。面试的时候就可以很谦虚的说，实际项目里面用过，但是用的不多6. application serverwebsphere、weblogic、jboss之类的就不用准备了，应该没人问你这些啦。有时间的话，看看tomcat和jetty的源代码，重点看线程模型和io，这将是一个很好的加分项7. 数据库oracle、sybase、db2不会有人关心了，如果之前没用过mysql的话，找本介绍innodb原理的书好好通读一遍吧。理解myisam和innodb的区别理解关系型数据库索引的原理，理解一些简单的索引优化的原则。面试官很喜欢给出一堆where子句，考索引、复合索引什么情况下起作用8. 缓存一致性哈希很多面试官喜欢考，提前准备下吧。9. ssh框架这些没搞过就没搞过吧，这种框架层面的东西，对于一个有经验的java码农，学起来也就是分分钟的事情。不过你也可以说这些我没用过，但是我知道原理，然后说一堆动态代理、cglib的原理出来，也是加分。希望这些对传统IT想转互联网的朋友有帮助。not in 与 not exists 有什么区别? in查询不对null进行处理二分，递归，还有冒泡，就差不多了作者：头条号 / 技术领地链接：http://toutiao.com/a6316391446829072641/来源：头条号（今日头条旗下创作平台）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring-boot-shiro集成]]></title>
      <url>%2F2016%2F08%2F08%2Fspring%20boot%20shiro%E9%9B%86%E6%88%90%2F</url>
      <content type="text"><![CDATA[spring boot shiro集成1234567891011121314151617181920&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.2.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.2.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt; &lt;version&gt;1.2.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-guice&lt;/artifactId&gt; &lt;version&gt;1.2.4&lt;/version&gt;&lt;/dependency&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126@Configurationpublic class ShiroConfig &#123; private static Map&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;String, String&gt;(); @Bean(name = "cacheShiroManager") public CacheManager getCacheManage() &#123; return new EhCacheManager(); &#125; @Bean(name = "lifecycleBeanPostProcessor") public LifecycleBeanPostProcessor getLifecycleBeanPostProcessor() &#123; return new LifecycleBeanPostProcessor(); &#125; @Bean(name = "sessionValidationScheduler") public ExecutorServiceSessionValidationScheduler getExecutorServiceSessionValidationScheduler() &#123; ExecutorServiceSessionValidationScheduler scheduler = new ExecutorServiceSessionValidationScheduler(); scheduler.setInterval(900000); return scheduler; &#125; @Bean(name = "hashedCredentialsMatcher") public HashedCredentialsMatcher getHashedCredentialsMatcher() &#123; HashedCredentialsMatcher credentialsMatcher = new HashedCredentialsMatcher(); credentialsMatcher.setHashAlgorithmName("MD5"); credentialsMatcher.setHashIterations(1); credentialsMatcher.setStoredCredentialsHexEncoded(true); return credentialsMatcher; &#125; @Bean(name = "sessionIdCookie") public SimpleCookie getSessionIdCookie() &#123; SimpleCookie cookie = new SimpleCookie("sid"); cookie.setHttpOnly(true); cookie.setMaxAge(-1); return cookie; &#125; @Bean(name = "rememberMeCookie") public SimpleCookie getRememberMeCookie() &#123; SimpleCookie simpleCookie = new SimpleCookie("rememberMe"); simpleCookie.setHttpOnly(true); simpleCookie.setMaxAge(2592000); return simpleCookie; &#125; @Bean public CookieRememberMeManager getRememberManager()&#123; CookieRememberMeManager meManager = new CookieRememberMeManager(); meManager.setCipherKey(Base64.decode("4AvVhmFLUs0KTA3Kprsdag==")); meManager.setCookie(getRememberMeCookie()); return meManager; &#125; @Bean(name = "sessionManager") public DefaultWebSessionManager getSessionManage() &#123; DefaultWebSessionManager sessionManager = new DefaultWebSessionManager(); sessionManager.setGlobalSessionTimeout(1800000); sessionManager.setSessionValidationScheduler(getExecutorServiceSessionValidationScheduler()); sessionManager.setSessionValidationSchedulerEnabled(true); sessionManager.setDeleteInvalidSessions(true); sessionManager.setSessionIdCookieEnabled(true); sessionManager.setSessionIdCookie(getSessionIdCookie()); EnterpriseCacheSessionDAO cacheSessionDAO = new EnterpriseCacheSessionDAO(); cacheSessionDAO.setCacheManager(getCacheManage()); sessionManager.setSessionDAO(cacheSessionDAO); // -----可以添加session 创建、删除的监听器 return sessionManager; &#125; @Bean(name = "myRealm") public AuthorizingRealm getShiroRealm() &#123; AuthorizingRealm realm = new ShiroRealm(getCacheManage(), getHashedCredentialsMatcher()); realm.setName("shiro_auth_cache"); realm.setAuthenticationCache(getCacheManage().getCache(realm.getName())); realm.setAuthenticationTokenClass(UserAuthenticationToken.class); return realm; &#125; @Bean(name = "securityManager") public DefaultWebSecurityManager getSecurityManager() &#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setCacheManager(getCacheManage()); securityManager.setSessionManager(getSessionManage()); securityManager.setRememberMeManager(getRememberManager()); securityManager.setRealm(getShiroRealm()); return securityManager; &#125; @Bean public MethodInvokingFactoryBean getMethodInvokingFactoryBean()&#123; MethodInvokingFactoryBean factoryBean = new MethodInvokingFactoryBean(); factoryBean.setStaticMethod("org.apache.shiro.SecurityUtils.setSecurityManager"); factoryBean.setArguments(new Object[]&#123;getSecurityManager()&#125;); return factoryBean; &#125; @Bean @DependsOn("lifecycleBeanPostProcessor") public DefaultAdvisorAutoProxyCreator getAutoProxyCreator()&#123; DefaultAdvisorAutoProxyCreator creator = new DefaultAdvisorAutoProxyCreator(); creator.setProxyTargetClass(true); return creator; &#125; @Bean public AuthorizationAttributeSourceAdvisor getAuthorizationAttributeSourceAdvisor()&#123; AuthorizationAttributeSourceAdvisor advisor = new AuthorizationAttributeSourceAdvisor(); advisor.setSecurityManager(getSecurityManager()); return advisor; &#125; @Bean(name = "shiroFilter") public ShiroFilterFactoryBean getShiroFilterFactoryBean()&#123; ShiroFilterFactoryBean factoryBean = new ShiroFilterFactoryBean(); factoryBean.setSecurityManager(getSecurityManager()); factoryBean.setLoginUrl("/toLogin"); filterChainDefinitionMap.put("/resources/**", "anon"); filterChainDefinitionMap.put("/login**", "anon"); filterChainDefinitionMap.put("/**", "user"); factoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap); return factoryBean; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ShiroRealm extends AuthorizingRealm &#123; public ShiroRealm(CacheManager cacheManager, CredentialsMatcher matcher) &#123; super(cacheManager, matcher); &#125; @Autowired private ManageUserService userService; @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection paramPrincipalCollection) &#123; SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); LoginUser user = (LoginUser) SecurityUtils.getSubject().getSession().getAttribute(AuthAppConfig.LOGIN_USER); if (user != null) &#123; // 当前用户角色编码集合 List&lt;String&gt; roleIds = new ArrayList&lt;&gt;(); for (LoginUserRole role : userService.findLoginUserRoles(user)) &#123; roleIds.add(String.valueOf(role.getId())); &#125; authorizationInfo.addRoles(roleIds); //TODO add permits //authorizationInfo.addStringPermissions(null); &#125; return authorizationInfo; &#125; @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; UserAuthenticationToken token = (UserAuthenticationToken) authenticationToken; if (StringUtils.isEmpty(token.getUsername())) &#123; throw new IncorrectCredentialsException("username is null!"); &#125; else if (StringUtils.isEmpty(token.getCredentials())) &#123; throw new IncorrectCredentialsException("password is null!"); &#125; LoginUser user = userService.findByUsername(token.getUsername()); if (user == null) &#123; // 用户不存在 throw new UnknownAccountException("The user does not exist"); &#125; String userPassword = userService.getUserPassword(user.getId()); return new SimpleAuthenticationInfo(token.getUsername(), userPassword, getName()); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class UserAuthenticationToken implements AuthenticationToken, RememberMeAuthenticationToken &#123; private static final long serialVersionUID = 1L; private String username; private String password; private boolean rememberMe; public UserAuthenticationToken(String username, String password, boolean rememberMe) &#123; super(); this.username = username; this.password = password; this.rememberMe = rememberMe; &#125; /** * 是否记住密码 */ @Override public boolean isRememberMe() &#123; return rememberMe; &#125; /** * 获取用户密码 */ @Override public Object getCredentials() &#123; return this.password.toCharArray(); &#125; /** * 获取用户登录名 */ @Override public String getPrincipal() &#123; return username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getUsername() &#123; return username; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决日志包冲突]]></title>
      <url>%2F2016%2F08%2F08%2F%E8%A7%A3%E5%86%B3%E6%97%A5%E5%BF%97%E5%8C%85%E5%86%B2%E7%AA%81%2F</url>
      <content type="text"><![CDATA[解决日志包冲突mvn dependency:list mvn dependency:tree -Dverbose -Dincludes=org.slf4j 找到 重复的 slf4j 然后 进行 排除 123456789101112131415 &lt;dependency&gt;&lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;&lt;artifactId&gt;shiro-core&lt;/artifactId&gt;&lt;version&gt;$&#123;shiro.version&#125;&lt;/version&gt;&lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt; &lt;/exclusion&gt;&lt;/exclusions&gt;&lt;/dependency&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用shell]]></title>
      <url>%2F2016%2F08%2F08%2F%E5%B8%B8%E7%94%A8shell%2F</url>
      <content type="text"><![CDATA[常用 shell123456789$# 是传给脚本的参数个数$0 是脚本本身的名字$1 是传递给该shell脚本的第一个参数$2 是传递给该shell脚本的第二个参数$@ 是传给脚本的所有参数的列表$* 是以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个$$ 是脚本运行的当前进程ID号$? 是显示最后命令的退出状态，0表示没有错误，其他表示有错误$UID 当前为root用户时值为0 12345查看文件cat 文件名|head -n 5cat 文件名|tail -n 2cat 文件名|sed -n &apos;x,yp&apos;打印出x,y行，p理解为print unable to create new native thread的错误异常 12345678910111213141516171819202122232425262728293031323334➜ ~ ulimit -u709[root@iZ2809ocw4jZ ~]# ulimit -acore file size (blocks, -c) 0data seg size (kbytes, -d) unlimitedscheduling priority (-e) 0file size (blocks, -f) unlimitedpending signals (-i) 7798max locked memory (kbytes, -l) 64max memory size (kbytes, -m) unlimitedopen files (-n) 65535pipe size (512 bytes, -p) 8POSIX message queues (bytes, -q) 819200real-time priority (-r) 0stack size (kbytes, -s) 10240cpu time (seconds, -t) unlimitedmax user processes (-u) 7798virtual memory (kbytes, -v) unlimitedfile locks (-x) unlimited注： ulimit -u是显示用户最多可开启的程序数目程序JVM参数设置如下：java OOMTest 4000 -Xmx500m -Xss2m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmpjava OOMTest 4000 -Xmx500m -Xss2m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmpjava OOMTest 40000 -Xmx500m -Xss2m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp使用ulimit -u 65535命令或者直接修改limits.conf文件，将max user process参数修改为65535。当max user processers 设置的较小的时候，影响系统线程数目的是max user processers的设置。当max user processers设置为65535的时候，影响系统线程数目的是系统的内存。对外的异常信息均为：OOM:unable to create native thread。 12345678910111213对于Java中的线程，我之前的理解一直是在Java中new新线程的时候是直接使用JVM的内存，可实际情况却不是这样的。在Java中每个线程需要分配线程内存，用来存储自身的线程变量，在JDK 1.4中每个线程是256K的内存，在JDK 1.5中每个线程是1M的内存，JDK 1.6以上版本不太清楚。在Java中每new一个线程，JVM都是向操作系统请求new一个本地线程，此时操作系统会使用剩余的内存空间来为线程分配内存，而不是使用JVM的内存。这样，当操作系统的可用内存越少，则JVM可用创建的新线程也就越少，我们举一个例子如下如何来分析当前系统配置能够支持多少线程呢？总内存 -Xmx -Xms -Xss 剩余内存 线程数1024M 256M 256M 1M 768M 768(MaxProcessMemory – JVMMemory – ReservedOsMemory) / (ThreadStackSize) = Number of threads解释下几个参数的含义：MaxProcessMemory：进程最大寻址空间。JVMMMEMORY：JVM内存空间（堆+永久区）-Xmx大小 (应该是实际分配大小)。ReservedOsMemory：操作系统预留内存。ThreadStackSize：-Xss大小。 12345678解决：1、优化程序，减少没用的log4j日志输出，将log4j日志改为异步+buffer的模式。2、单台服务器本身性能有限，通过增加服务器的方式提高扩展性。3、将系统的一些限制属性增大，如：ulimit -a。4、当发现这个错误的时候，第一时间要排查程序是否有bug，是否大量的创建了线程，或者没有正确使用线程池，比如：是否使用了Executors.newCachedThreadPool()方法，该方法能创建Integer最大值个线程，创建到一定程度的时候系统资源耗尽就会报错。5、如果发现程序中并没有使用线程却依然报这个错，那么观察一下这个时刻的并发情况如何，要是溢出的这一时刻比其他时候并发量都要大，这时先查看一下系统资源的情况，使用ulimit –a查看max user processes和open files这二个属性的值越大，能创建的线程数也就越大。6、如果以上二个属性调大依然报错的话，说明此时受限于系统内存资源了，要是服务器本身内存就比较小的话，建议增加内存。要是服务器内存比较大，就需要通过调整jvm参数来增加线程使用的内存，比如减小-Xss值，这个值越小能创建的线程数也就越多，也可以适当减少-Xmx和-Xms的值，增加堆外内存的容量。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[rsync使用]]></title>
      <url>%2F2016%2F08%2F08%2Frsync%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[rsync语法 1$ rsync options source destination Example 1. Synchronize Two Directories in a Local Server |不同步时间戳12345678$ rsync -zvr /var/opt/installation/inventory/ /root/tempbuilding file list ... donesva.xmlsvB.xml.sent 26385 bytes received 1098 bytes 54966.00 bytes/sectotal size is 44867 speedup is 1.63$ -z is to enable compression -v verbose -r indicates recursive Example 2. Preserve timestamps during Sync using rsync -a |同步时间戳123456789$ rsync -azv /var/opt/installation/inventory/ /root/temp/building file list ... done./sva.xmlsvB.xml.sent 26499 bytes received 1104 bytes 55206.00 bytes/sectotal size is 44867 speedup is 1.63$ Example 3. Synchronize Only One File12345$ rsync -v /var/lib/rpm/Pubkeys /root/temp/Pubkeyssent 42 bytes received 12380 bytes 3549.14 bytes/sectotal size is 12288 speedup is 0.99 Example 4. Synchronize Files From Local to Remote12345678910$ rsync -avz /root/temp/ thegeekstuff@192.168.200.10:/home/thegeekstuff/temp/Password:building file list ... done./rpm/rpm/Basenamesrpm/Conflictnamesent 15810261 bytes received 412 bytes 2432411.23 bytes/sectotal size is 45305958 speedup is 2.87 Example 5. Synchronize Files From Remote to Local12345678$ rsync -avz thegeekstuff@192.168.200.10:/var/lib/rpm /root/tempPassword:receiving file list ... donerpm/rpm/Basenames.sent 406 bytes received 15810230 bytes 2432405.54 bytes/sectotal size is 45305958 speedup is 2.87 Example 6. Remote shell for Synchronization12345678$ rsync -avz -e ssh thegeekstuff@192.168.200.10:/var/lib/rpm /root/tempPassword:receiving file list ... donerpm/rpm/Basenamessent 406 bytes received 15810230 bytes 2432405.54 bytes/sectotal size is 45305958 speedup is 2.87 Example 7. Do Not Overwrite the Modified Files at the Destination123456789101112131415$ ls -l /root/temp/Basenamestotal 39088-rwxr-xr-x 1 root root 4096 Sep 2 11:35 Basenames$ rsync -avzu thegeekstuff@192.168.200.10:/var/lib/rpm /root/tempPassword:receiving file list ... donerpm/sent 122 bytes received 505 bytes 114.00 bytes/sectotal size is 45305958 speedup is 72258.31$ ls -lrttotal 39088-rwxr-xr-x 1 root root 4096 Sep 2 11:35 Basenames Example 8. Synchronize only the Directory Tree Structure (not the files)12345678910$ rsync -v -d thegeekstuff@192.168.200.10:/var/lib/ .Password:receiving file list ... donelogrotate.statusCAM/YaST2/acpi/sent 240 bytes received 1830 bytes 318.46 bytes/sectotal size is 956 speedup is 0.46 Example 9. View the rsync Progress during Transfer1234567891011121314$ rsync -avz --progress thegeekstuff@192.168.200.10:/var/lib/rpm/ /root/temp/Password:receiving file list ...19 files to consider./Basenames 5357568 100% 14.98MB/s 0:00:00 (xfer#1, to-check=17/19)Conflictname 12288 100% 35.09kB/s 0:00:00 (xfer#2, to-check=16/19)...sent 406 bytes received 15810211 bytes 2108082.27 bytes/sectotal size is 45305958 speedup is 2.87 Example 10. Delete the Files Created at the Target1234567891011# Source and target are in sync. Now creating new file at the target.$ &gt; new-file.txt$ rsync -avz --delete thegeekstuff@192.168.200.10:/var/lib/rpm/ .Password:receiving file list ... donedeleting new-file.txt./sent 26 bytes received 390 bytes 48.94 bytes/sectotal size is 45305958 speedup is 108908.55 Example 11. Do not Create New File at the TargetIf you like, you can update (Sync) only the existing files at the target. In case source has new files, which is not there at the target, you can avoid creating these new files at the target. If you want this feature, use –existing option with rsync command.First, add a new-file.txt at the source. 1[/var/lib/rpm ]$ &gt; new-file.txt Next, execute the rsync from the target. 1234567$ rsync -avz --existing root@192.168.1.2:/var/lib/rpm/ .root@192.168.1.2&apos;s password:receiving file list ... done./sent 26 bytes received 419 bytes 46.84 bytes/sectotal size is 88551424 speedup is 198991.96 If you see the above output, it didn’t receive the new file new-file.txt Example 12. View the Changes Between Source and DestinationAt the source: 1234$ ls -l /var/lib/rpm-rw-r--r-- 1 root root 5357568 2010-06-24 08:57 Basenames-rw-r--r-- 1 root root 12288 2008-05-28 22:03 Conflictname-rw-r--r-- 1 root root 1179648 2010-06-24 08:57 Dirnames At the destination: 1234$ ls -l /root/temp-rw-r--r-- 1 root root 12288 May 28 2008 Conflictname-rw-r--r-- 1 bin bin 1179648 Jun 24 05:27 Dirnames-rw-r--r-- 1 root root 0 Sep 3 06:39 Basenames In the above example, between the source and destination, there are two differences. First, owner and group of the file Dirname differs. Next, size differs for the file Basenames. Now let us see how rsync displays this difference. -i option displays the item changes. 12345678$ rsync -avzi thegeekstuff@192.168.200.10:/var/lib/rpm/ /root/temp/Password:receiving file list ... done&gt;f.st.... Basenames.f....og. Dirnamessent 48 bytes received 2182544 bytes 291012.27 bytes/sectotal size is 45305958 speedup is 20.76 In the output it displays some 9 letters in front of the file name or directory name indicating the changes. In our example, the letters in front of the Basenames (and Dirnames) says the following: 123456&gt; specifies that a file is being transferred to the local host.f represents that it is a file.s represents size changes are there.t represents timestamp changes are there.o owner changedg group changed. Example 13. Include and Exclude Pattern during File Transferrsync allows you to give the pattern you want to include and exclude files or directories while doing synchronization. 1234567891011$ rsync -avz --include &apos;P*&apos; --exclude &apos;*&apos; thegeekstuff@192.168.200.10:/var/lib/rpm/ /root/temp/Password:receiving file list ... done./PackagesProvidenameProvideversionPubkeyssent 129 bytes received 10286798 bytes 2285983.78 bytes/sectotal size is 32768000 speedup is 3.19 Example 14. Do Not Transfer Large FilesYou can tell rsync not to transfer files that are greater than a specific size using rsync –max-size option. 1234567891011121314$ rsync -avz --max-size=&apos;100K&apos; thegeekstuff@192.168.200.10:/var/lib/rpm/ /root/temp/Password:receiving file list ... done./ConflictnameGroupInstalltidNameSha1headerSigmd5Triggernamesent 252 bytes received 123081 bytes 18974.31 bytes/sectotal size is 45305958 speedup is 367.35 max-size=100K makes rsync to transfer only the files that are less than or equal to 100K. You can indicate M for megabytes and G for gigabytes. Example 15. Transfer the Whole FileOne of the main feature of rsync is that it transfers only the changed block to the destination, instead of sending the whole file. If network bandwidth is not an issue for you (but CPU is), you can transfer the whole file, using rsync -W option. This will speed-up the rsync process, as it doesn’t have to perform the checksum at the source and destination. 1234567891011121314# rsync -avzW thegeekstuff@192.168.200.10:/var/lib/rpm/ /root/tempPassword:receiving file list ... done./BasenamesConflictnameDirnamesFilemd5sGroupInstalltidNamesent 406 bytes received 15810211 bytes 2874657.64 bytes/sectotal size is 45305958 speedup is 2.87]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[多tomcat部署|端口修改]]></title>
      <url>%2F2016%2F08%2F08%2F%E5%A4%9Atomcat%E9%83%A8%E7%BD%B2%7C%E7%AB%AF%E5%8F%A3%E4%BF%AE%E6%94%B9%2F</url>
      <content type="text"><![CDATA[多tomcat部署|端口修改tomcat服务器需配置三个端口才能启动，安装时默认启用了这三个端口，当要运行多个tomcat服务时需要修改这三个端口，不能相同。 端口一：修改http访问端口（默认为8080端口），配置文件为tomcat\ conf\service.xml &lt;!– 端口二：修改Shutdown远程停服务端口（默认为8005端口） 端口三： 修改AJP端口（默认为8009端口）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jvm内存小结]]></title>
      <url>%2F2016%2F08%2F08%2Fjvm%E5%86%85%E5%AD%98%E5%B0%8F%E7%BB%93%2F</url>
      <content type="text"><![CDATA[jvm 内存小结1234567891011PermGen space的全称是Permanent Generation space,是指内存的永久保存区域, 这块内存主要是被JVM存放Class和Meta信息的,Class在被Loader时就会被放到PermGen space中, 它和存放类实例(Instance)的Heap区域不同,GC(Garbage Collection)不会在主程序运行期对 PermGen space进行清理，所以如果你的应用中有很多CLASS的话,就很可能出现PermGen space错误, 这种错误常见在web服务器对JSP进行pre compile的时候。如果你的WEB APP下都用了大量的第三方jar,其大小超过了jvm默认的大小(4M)那么就会产生此错误信息了。 解决方法： 手动设置MaxPermSize大小 -XX:MaxPermSize=128m(这个是按照内存1G配置，如果你的内存足够大，你可以设置大于128) 改正方法：-Xms256m -Xmx256m -XX:MaxNewSize=256m -XX:MaxPermSize=256m 12345Heap Memory是堆内存，Stack Memory是栈内存Heap size 的大小是Young Generation 和Tenured Generaion 之和Stack memory内存空间由操作系统自动分配和释放，Heap Memory内存空间手动申请和释放的，Heap Memory内存常用new关键字来分配。Stack Memory内存空间有限，Heap Memor的空间是很大的自由区几乎没有空间限制。 12345678910111213141516171819202122232425Heap size 设置 JVM堆的设置是指java程序运行过程中JVM可以调配使用的内存空间的设置.JVM在启动的时候会自动设置Heap size的值其初始空间(即-Xms)是物理内存的1/64，最大空间(-Xmx)是物理内存的1/4。可以利用JVM提供的-Xmn -Xms -Xmx等选项可Heap size 的大小是Young Generation 和Tenured Generaion 之和提示：在JVM中如果98％的时间是用于GC且可用的Heap size 不足2％的时候将抛出此异常信息提示：Heap Size 最大不要超过可用物理内存的80％，一般的要将-Xms和-Xmx选项设置为相同，而-Xmn为1/4的-Xmx值解决方法：手动设置Heap size 修改TOMCAT_HOME/bin/catalina.sh 在“echo &quot;Using CATALINA_BASE: $CATALINA_BASE&quot;”上面加入以下行： JAVA_OPTS=&quot;-server -Xms800m -Xmx800m -XX:MaxNewSize=256m&quot; 1G内存环境下JVM参数设置参考:JAVA_OPTS=&quot;-server -Xms800m -Xmx800m -XX:PermSize=64M -XX:MaxNewSize=256m -XX:MaxPermSize=128m -Djava.awt.headless=true &quot; -Xms：初始值 intial java heap size-Xmx：最大值 maximum java heap size-Xmn：最小值 minimum java heap sizeXss: the stack size for each thread 1234567catalina.sh加set JAVA_OPTS=&apos;-Xms64 -Xmx512&apos;无效解决方案set JAVA_OPTS=&apos;-Xms64 -Xmx512&apos;上面无效的话这样写：declare -x JAVA_OPTS=&quot;-Xms128m -Xmx256&quot;&quot;declare -x&quot;一定要加，不然就会报-x指令无效，还有后面的引号也要注意加上 wq后，重启tomcat即可，ps ax后看到tomcat的进程会变成类似/opt/jdk1.6.0/bin/java -Xms128m -Xmx256m -Djava.endorsed.dirs=/opt/tomcat/common/e]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Centos6.5使用yum安装mysql]]></title>
      <url>%2F2016%2F08%2F08%2FCentos6.5%E4%BD%BF%E7%94%A8yum%E5%AE%89%E8%A3%85mysql%2F</url>
      <content type="text"><![CDATA[Centos6.5使用yum安装mysql1234567891011121314151617181920212223242526272829303132333435363738第1步、yum安装mysql[root@stonex ~]# yum -y install mysql-server安装结果：Installed: mysql-server.x86_64 0:5.1.73-3.el6_5 Dependency Installed: mysql.x86_64 0:5.1.73-3.el6_5 perl-DBD-MySQL.x86_64 0:4.013-3.el6 perl-DBI.x86_64 0:1.609-4.el6第2步、设置开机启动[root@stonex ~]# chkconfig mysqld on第3步、启动MySql服务[root@stonex ~]# service mysqld start第4步、设置MySQL的root用户设置密码[root@stonex ~]# mysql -u rootWelcome to the MySQL monitor. Commands end with ; or \g....... 省略了一些行mysql&gt; select user,host,password from mysql.user;查询用户的密码，都为空，用下面的命令设置root的密码为rootmysql&gt; set password for root@localhost=password(&apos;root&apos;);mysql&gt; exit第5步、用新密码登陆[root@stonex ~]# mysql -u root -p第6步、基本命令show databases; //查看系统已存在的数据库use databasesname; //选择需要使用的数据库drop database databasename; //删除选定的数据库exit //退出数据库的连接create database test01; //建立名为test的数据库show tables; // 列出当前数据库下的表其他基本的增删改查使用标准SQL即可第7步、开放远程登录权限GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;root&apos; WITH GRANT OPTION;FLUSH PRIVILEGES;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8|tomcat8安装脚本]]></title>
      <url>%2F2016%2F08%2F08%2Fjdk8%7Ctomcat8%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC%2F</url>
      <content type="text"><![CDATA[jdk8|tomcat8安装脚本123456789101112131415161718192021222324252627#!/bin/bashecho &quot;beigin install jdk-1.7&quot;# sudo su #切换到root权限mkdir /usr/local/javacd /usr/local/java#download jdk 1.7.67wget --no-check-certificate --no-cookies --header &quot;Cookie: oraclelicense=accept-securebackup-cookie&quot; http://download.oracle.com/otn-pub/java/jdk/7u67-b01/jdk-7u67-linux-x64.tar.gz#extract jdktar -xvf jdk-7u67-linux-x64.tar.gz#set environmentexport JAVA_HOME=&quot;/usr/local/java/jdk1.7.0_67&quot;if ! grep &quot;JAVA_HOME=/usr/local/java/jdk1.7.0_67&quot; /etc/environment then echo &quot;JAVA_HOME=/usr/local/java/jdk1.7.0_67&quot; | sudo tee -a /etc/environment echo &quot;export JAVA_HOME&quot; | sudo tee -a /etc/environment echo &quot;PATH=$PATH:$JAVA_HOME/bin&quot; | sudo tee -a /etc/environment echo &quot;export PATH&quot; | sudo tee -a /etc/environment echo &quot;CLASSPATH=.:$JAVA_HOME/lib&quot; | sudo tee -a /etc/environment echo &quot;export CLASSPATH&quot; | sudo tee -a /etc/environment fi#update environmentsource /etc/environment echo &quot;jdk is installed !&quot; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#!/bin/bashecho &quot;开始安装 jdk-1.8&quot;JDK_INSTALL_PATH=&quot;/data/soft/java&quot;JDK_TAR_FILE=&quot;jdk-8u51-linux-x64.tar.gz&quot;JDK_FILE=&quot;jdk1.8.0_51&quot;ENV_DIR=&quot;/data/env&quot;ENV_FILE=&quot;$ENV_DIR/environment&quot;if [ ! -d &quot;$ENV_DIR&quot; ];then echo &quot;环境文件目录不存在，创建目录[$ENV_DIR]&quot; mkdir -p $ENV_DIRfiif [ ! -d &quot;$JDK_INSTALL_PATH&quot; ] ; then echo &quot;安装目录不存在，创建安装目录[$JDK_INSTALL_PATH]&quot; mkdir -p $JDK_INSTALL_PATHfiif [ ! -f &quot;$JDK_TAR_FILE&quot; ] ; then echo &quot;JDK安装包不存在，开始下载安装包&quot; wget --no-check-certificate --no-cookies --header &quot;Cookie: oraclelicense=accept-securebackup-cookie&quot; http://download.oracle.com/otn-pub/java/jdk/8u51-b16/jdk-8u51-linux-x64.tar.gz echo &quot;JDK安装包下载完成&quot; #cp ./$JDK_TAR_FILE $JDK_INSTALL_PATHficp ./$JDK_TAR_FILE $JDK_INSTALL_PATHcd $JDK_INSTALL_PATHif [ -d &quot;$JDK_INSTALL_PATH/$JDK_FILE&quot; ]; then echo &quot;删除已存在目录[$JDK_INSTALL_PATH/$JDK_FILE],重新解压缩&quot; rm -rf $JDK_INSTALL_PATH/$JDK_FILEfitar -xvf $JDK_TAR_FILEecho &quot;解压缩安装包完成。。。&quot;if [ ! -f &quot;$ENV_FILE&quot; ]; then echo &quot;环境变量文件不存在，创建文件[$ENV_FILE]&quot; touch $ENV_FILEfiecho &quot;配置环境变量开始&quot;if ! grep &quot;JAVA_HOME=&quot; /data/env/environment then echo &quot;JAVA_HOME=$JDK_INSTALL_PATH/$JDK_FILE&quot; | tee -a $ENV_FILE echo &quot;export JAVA_HOME&quot; | tee -a $ENV_FILE echo &apos;PATH=$PATH:$JAVA_HOME/bin&apos; | tee -a $ENV_FILE echo &quot;export PATH&quot; | tee -a $ENV_FILE echo &apos;CLASSPATH=.:$JAVA_HOME/lib&apos; | tee -a $ENV_FILE echo &quot;export CLASSPATH&quot; | tee -a $ENV_FILEfiecho &quot;JDK安装完成&quot; 123456789101112131415161718192021222324252627#!/bin/bashecho &quot;开始安装 tomcat-8.0&quot;JDK_INSTALL_PATH=&quot;/data/soft/tomcat&quot;JDK_TAR_FILE=&quot;apache-tomcat-8.0.24.tar.gz&quot;JDK_FILE=&quot;apache-tomcat-8.0.24&quot;if [ ! -d &quot;$JDK_INSTALL_PATH&quot; ] ; then echo &quot;安装目录不存在，创建安装目录[$JDK_INSTALL_PATH]&quot; mkdir -p $JDK_INSTALL_PATHfiif [ ! -f &quot;$JDK_TAR_FILE&quot; ] ; then echo &quot;TOMCAT安装包不存在，开始下载安装包&quot; wget --no-check-certificate --no-cookies --header &quot;Cookie: oraclelicense=accept-securebackup-cookie&quot; http://mirrors.cnnic.cn/apache/tomcat/tomcat-8/v8.0.24/bin/apache-tomcat-8.0.24.tar.gz echo &quot;TOMCAT安装包下载完成&quot;# cp ./$JDK_TAR_FILE $JDK_INSTALL_PATHficp ./$JDK_TAR_FILE $JDK_INSTALL_PATHcd $JDK_INSTALL_PATHif [ -d &quot;$JDK_INSTALL_PATH/$JDK_FILE&quot; ]; then echo &quot;删除已存在目录[$JDK_INSTALL_PATH/$JDK_FILE],重新解压缩&quot; rm -rf $JDK_INSTALL_PATH/$JDK_FILEfitar -xvf $JDK_TAR_FILEecho &quot;解压缩安装包完成。。。&quot;echo &quot;TOMCAT安装完成&quot;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[sshpass的使用]]></title>
      <url>%2F2016%2F08%2F08%2Fsshpass%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[sshpass的使用安装sshpasswget http://nchc.dl.sourceforge.net/project/sshpass/sshpass/1.05/sshpass-1.05.tar.gz 1234567tar zxvf sshpass-1.05.tar.gzcd sshpass-1.05./configuremake &amp;&amp; make install sshpass简单示例 1sshpass -p &lt;password&gt; ssh &lt;username&gt;@&lt;server_ip&gt; &quot;&lt;command&gt;&quot;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac Redis 使用]]></title>
      <url>%2F2016%2F07%2F06%2FMac%20Redis%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[Mac Redis 使用1234567891011121314151617181920212223242526272829303132333435363738$ brew install redis #安装==&gt; Downloading https://homebrew.bintray.com/bottles/redis-3.2.0.el_capitan.bottle.tar.gz######################################################################## 100.0%==&gt; Pouring redis-3.2.0.el_capitan.bottle.tar.gz==&gt; CaveatsTo have launchd start redis now and restart at login: brew services start redisOr, if you don&apos;t want/need a background service you can just run: redis-server /usr/local/etc/redis.conf==&gt; Summary🍺 /usr/local/Cellar/redis/3.2.0: 10 files, 1.7M$ brew services start redis #To have launchd start redis now and restart at login==&gt; Tapping homebrew/servicesCloning into &apos;/usr/local/Library/Taps/homebrew/homebrew-services&apos;...remote: Counting objects: 7, done.remote: Compressing objects: 100% (6/6), done.remote: Total 7 (delta 0), reused 3 (delta 0), pack-reused 0Unpacking objects: 100% (7/7), done.Checking connectivity... done.Tapped 0 formulae (32 files, 46.1K)==&gt; Successfully started `redis` (label: homebrew.mxcl.redis)$ redis-server #Starting Redis,查看当前redis运行情况$ redis-cli ping #检查是否启动PONG$ redis-cli # 进入redis 命令127.0.0.1:6379&gt; pingPONG127.0.0.1:6379&gt; set mykey helloOK127.0.0.1:6379&gt; get mykey&quot;hello&quot;127.0.0.1:6379&gt;$ redis-cli shutdown #控制台输入 关闭命令命令路径：~ /usr/local/bin/redis-server /usr/local/etc/redis.conf Mac redis 客户端的安装 12345# Install Homebrew cask$ brew install caskroom/cask/brew-cask # Install Redis Desktop Manager aka RDM$ brew cask install rdm http://www.tuicool.com/articles/nM73Enr http://my.oschina.net/jackieyeah/blog/524583 http://docs.redisdesktop.com/en/latest/install/#mac-os-x]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Velocity语法]]></title>
      <url>%2F2016%2F07%2F04%2FVelocity%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[Velocity语法 “#”用来标识Velocity的脚本语句，包括#set、#if 、#else、#end、#foreach、#end、#include、#parse、#macro等； 1234567891011#if($info.imgs)&lt;img src=&quot;$info.imgs&quot; border=0&gt;#else&lt;img src=&quot;noPhoto.jpg&quot;&gt;#end#foreach( $info in $list) $info.someList #end#macro(macroName)#end ##脚本函数(宏)调用，不推荐在界面模板中大量使用 “$”用来标识一个对象(或理解为变量)； 1234$i$msg$TagUtil.options(...)$!obj ##直接返回对象结果。 “{}”用来明确标识Velocity变量； 1比如在页面中，页面中有一个$someonename，此时，Velocity将把someonename作为变量名，若我们程序是想在someone这 个变量的后面紧接着显示name字符，则上面的标签应该改成$&#123;someone&#125;name “!”用来强制把不存在的变量显示为空白 12如当页面中包含$msg，如果msg对象有值，将显示msg的值，如果不存在msg对象同，则在页面中将显示$msg字符。这是我们不希望的，为了把不存 在的变量或变量值为null的对象显示为空白，则只需要在变量名前加一个“!”号即可。如：$!msg 包含文件#inclue(“模板文件名”)或#parse(“模板文件名”) 12主要用于处理具有相同内容的页面，比如每个网站的顶部或尾部内容。如：#parse(&quot;/blog/top.html&quot;)或#include(&quot;/blog/top.html&quot;)parse与include的区别在于，若包含的文件中有Velocity脚本标签，将会进一步解析，而include将原样显示。 关于#set的使用 123456在万不得已的时候，不要在页面视图自己声明Velocity脚本变量，也就是尽量少使用#set。有时候我们需要在页面中显示序号，而程序对象中又没有包 含这个序号属性同，可以自己定义。如在一个循环体系中，如下所示：#set ($i=0)#foreach($info in $list)序号:$i#set($i=$i+1)#end 语法摘要 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101、声明:#set ($var=XXX)左边可以是以下的内容Variable referenceString literalProperty referenceMethod referenceNumber literal #set ($i=1)ArrayList #set ($arr=[&quot;yt1&quot;,&quot;t2&quot;])算术运算符2、注释:单行## XXX多行#* xxxxxxxxxxxxxxxxxxx*#References 引用的类型3、变量 Variables以 &quot;$&quot; 开头，第一个字符必须为字母。character followed by a VTL Identifier. (a .. z or A .. Z).变量可以包含的字符有以下内容：alphabetic (a .. z, A .. Z)numeric (0 .. 9)hyphen (&quot;-&quot;)underscore (&quot;_&quot;)4、Properties$Identifier.Identifier$user.namehashtable user中的的name值.类似：user.get(&quot;name&quot;)5、Methodsobject user.getName() = $user.getName()6、Formal Reference Notation用&#123;&#125;把变量名跟字符串分开如#set ($user=&quot;csy&quot;&#125;$&#123;user&#125;name返回csyname$username$!username$与$!的区别当找不到username的时候，$username返回字符串&quot;$username&quot;，而$!username返回空字符串&quot;&quot;7、双引号 与 引号#set ($var=&quot;helo&quot;)test&quot;$var&quot; 返回testhellotest&apos;$var&apos; 返回test&apos;$var&apos;可以通过设置 stringliterals.interpolate=false改变默认处理方式8、条件语句#if( $foo )&lt;strong&gt;Velocity!&lt;/strong&gt;#end#if($foo)#elseif()#else#end当$foo为null或为Boolean对象的false值执行.9、逻辑运算符:== &amp;&amp; || !10、循环语句#foreach($var in $arrays ) // 集合包含下面三种Vector, a Hashtable or an Array#end#foreach( $product in $allProducts )&lt;li&gt;$product&lt;/li&gt;#end#foreach( $key in $allProducts.keySet() )&lt;li&gt;Key: $key -&gt; Value: $allProducts.get($key)&lt;/li&gt;#end#foreach( $customer in $customerList )&lt;tr&gt;&lt;td&gt;$velocityCount&lt;/td&gt;&lt;td&gt;$customer.Name&lt;/td&gt;&lt;/tr&gt;#end11、velocityCount变量在配置文件中定义# Default name of the loop counter# variable reference.directive.foreach.counter.name = velocityCount# Default starting value of the loop# counter variable reference.directive.foreach.counter.initial.value = 112、包含文件#include( &quot;one.gif&quot;,&quot;two.txt&quot;,&quot;three.htm&quot; )13、Parse导入脚本#parse(&quot;me.vm&quot; )14、#stop 停止执行并返回15、定义宏Velocimacros ,相当于函数 支持包含功能#macro( d )&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;#end调用#d()16、带参数的宏#macro( tablerows $color $somelist )#foreach( $something in $somelist )&lt;tr&gt;&lt;td bgcolor=$color&gt;$something&lt;/td&gt;&lt;/tr&gt;#end#end17、Range Operator#foreach( $foo in [1..5] )]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[maven的resources、filter和profile实现不同环境使用不同配置文件]]></title>
      <url>%2F2016%2F06%2F22%2Fmaven%E7%9A%84resources%E3%80%81filter%E5%92%8Cprofile%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[maven的resources、filter和profile实现不同环境使用不同配置文件 利用filter实现对资源文件(resouces)过滤 maven filter可利用指定的xxx.properties中对应的key=value对资源文件中的${key}进行替换，最终把你的资源文件中的username=${key}替换成username=value 利用profile来切换环境 maven profile可使用操作系统信息，jdk信息，文件是否存在，属性值等作为依据，来激活相应的profile，也可在编译阶段，通过mvn命令加参数 -PprofileId 来手工激活使用对应的profile结合filter和profile，我们就可以方便的在不同环境下使用不同的配制 pom.xml中标签中过滤资源文件 12345678910111213141516171819&lt;!-- 先指定 src/main/resources下所有文件及文件夹为资源文件 --&gt;&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;!-- 设置对auto-config.properties，jdbc.properties进行过虑，即这些文件中的$&#123;key&#125;会被替换掉为真正的值 --&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;application.properties&lt;/include&gt; &lt;include&gt;jdbc.properties&lt;/include&gt; &lt;include&gt;log4j.properties&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt;&lt;/resources&gt; 12345678910111213141516171819202122232425262728&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;log.home&gt;$&#123;user.home&#125;/logs/dev.log&lt;/log.home&gt; &lt;log4j.level&gt;debug&lt;/log4j.level&gt; &lt;jdbc.driver&gt;&lt;/jdbc.driver&gt; &lt;jdbc.url&gt;&lt;/jdbc.url&gt; &lt;jdbc.username&gt;&lt;/jdbc.username&gt; &lt;jdbc.password&gt;&lt;/jdbc.password&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;release&lt;/id&gt; &lt;properties&gt; &lt;log.home&gt;/app/tomcat/logs/product.log&lt;/log.home&gt; &lt;log4j.level&gt;debug&lt;/log4j.level&gt; &lt;jdbc.driver&gt;&lt;/jdbc.driver&gt; &lt;jdbc.url&gt;&lt;/jdbc.url&gt; &lt;jdbc.username&gt;&lt;/jdbc.username&gt; &lt;jdbc.password&gt;&lt;/jdbc.password&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt; 打包命令 mvn package -P dev mvn clean install -Dmaven.test.skip=true -P dev 123$ maven clean install -Pdev$ maven clean install -Ptest$ maven clean install -Prelease Notice：插件maven-help-plugin提供了一个目标帮助用户了解当前激活的profile： 12$ mvn help:active-profiles $ mvn help:all-profiles # 另外还有一个目标来列出当前所有的profile：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux（CentOS）下，下载安装Nginx并配置]]></title>
      <url>%2F2016%2F06%2F13%2FLinux(CentOS)%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85Nginx%E5%B9%B6%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[Linux（CentOS）下，下载安装Nginx并配置准备工作安装GCC，PCRE（Perl Compatible Regular Expression），zlib，OpenSSL 查看gcc是否安装 12345$ gcc如果出现“gcc: no input files”信息，说明已经安装好了.否则$ yum install gcc # 安装gcc，一路输入 y$ gcc -v # 查看版本号 同样方法安装pcre zlib openssl(其中devel，是develop开发包的意思) 123$ yum install -y pcre pcre-devel $ yum install -y zlib zlib-devel $ yum install -y openssl openssl-devel 下载并安装nginx1234567891011121314$ mkdir nginx-src &amp;&amp; cd nginx-src $ wget http://nginx.org/download/nginx-1.8.0.tar.gz $ tar xzf nginx-1.8.0.tar.gz $ cd nginx-1.8.0 $ ./configure $ make $ make install $ whereis nginx # nginx: /usr/local/nginx# 默认的安装路径为：/usr/local/nginx；跳转到其目录下sbin路径下，便可以启动或停止它了。$ cd /usr/local/nginx/sbin$ ./nginx -h #help$ nginx #启动$ nginx -s stop #停止 安装完之后信息说明： 12345678910111213141516171819Configuration summary + using system PCRE library + OpenSSL library is not used + md5: using system crypto library + sha1: using system crypto library + using system zlib library nginx path prefix: &quot;/usr/local/nginx&quot; nginx binary file: &quot;/usr/local/nginx/sbin/nginx&quot; nginx configuration prefix: &quot;/usr/local/nginx/conf&quot; nginx configuration file: &quot;/usr/local/nginx/conf/nginx.conf&quot; nginx pid file: &quot;/usr/local/nginx/logs/nginx.pid&quot; nginx error log file: &quot;/usr/local/nginx/logs/error.log&quot; nginx http access log file: &quot;/usr/local/nginx/logs/access.log&quot; nginx http client request body temporary files: &quot;client_body_temp&quot; nginx http proxy temporary files: &quot;proxy_temp&quot; nginx http fastcgi temporary files: &quot;fastcgi_temp&quot; nginx http uwsgi temporary files: &quot;uwsgi_temp&quot; nginx http scgi temporary files: &quot;scgi_temp&quot; 添加到系统服务使用命令“# vi /etc/init.d/nginx”，打开编辑器，输入如下内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#!/bin/sh# chkconfig: 2345 85 15# Startup script for the nginx Web Server# description: nginx is a World Wide Web server. # It is used to serve HTML files and CGI.# processname: nginx# pidfile: /usr/local/nginx/logs/nginx.pid# config: /usr/local/nginx/conf/nginx.confPATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/binDESC="nginx deamon"NAME=nginxDAEMON=/usr/local/nginx/sbin/$NAMESCRIPTNAME=/etc/init.d/$NAMEtest -x $DAEMON || exit 0d_start()&#123; $DAEMON || echo -n "already running"&#125;d_stop()&#123; $DAEMON -s quit || echo -n "not running"&#125;d_reload()&#123; $DAEMON -s reload || echo -n "can not reload"&#125;case "$1" instart) echo -n "Starting $DESC: $NAME" d_start echo ".";;stop) echo -n "Stopping $DESC: $NAME" d_stop echo ".";;reload) echo -n "Reloading $DESC conf..." d_reload echo "reload .";;restart) echo -n "Restarting $DESC: $NAME" d_stop sleep 2 d_start echo ".";;*) echo "Usage: $ScRIPTNAME &#123;start|stop|reload|restart&#125;" &gt;&amp;2 exit 3;;esacexit 0 保存退出后，再使用下面的命令，使其可执行；然后，添加配置并查看。可用chkconfig修改其值，也可用ntsysv工具改变是否自启动。 12345$ chmod +x /etc/init.d/nginx $ chkconfig --add nginx $ chkconfig nginx on/off $ chkconfig --list nginx # nginx 0:off 1:off 2:on 3:on 4:on 5:on 6:off 配置文件分散管理，include /usr/local/nginx/conf.d/*.conf;12345678$ cd /usr/local/nginx/conf$ vim nginx.conf# 加入 include /usr/local/nginx/conf.d/*.conf;$ cd /usr/local/nginx$ mkdir conf.d$ cd conf.d$ touch a.conf# a.conf 加入配置 123456789101112131415161718192021222324server &#123; listen 80; server_name localhost; location / &#123; proxy_pass http://114.215.93.103:8080; proxy_next_upstream http_500 http_502 http_503 error timeout invalid_header; proxy_redirect off; proxy_ignore_client_abort on; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 10m; client_body_buffer_size 512k; proxy_connect_timeout 300; proxy_send_timeout 300; proxy_read_timeout 300; proxy_buffer_size 256k; proxy_buffers 4 256k; proxy_busy_buffers_size 256k; proxy_temp_file_write_size 256k;# access_log /opt/wwwlogs/iplat_caihuike_com_access.log; &#125;&#125; 注意：nginx.conf里面的默认配置需要注释掉 80 的 server 配置，防止重复配置 localhost 测试123$ cd /usr/local/nginx$ ./sbin/nginx -t # 测试$ ./sbin/nginx -s reload # 重启]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[VIM的使用]]></title>
      <url>%2F2016%2F06%2F10%2FVIM%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[Welcome use ！ VIM的使用 一次移动一个光标 12h j k l ← ↓ ↑ → 行内移动 123456789100 到行首(相当于Home键)$ 到行尾(相当于End键)d0|d^ 删除至行首d$ 删除至行尾G 到文件尾50G 到50行gg 到文件首 d|D 剪切 （del word） 12345678dd 剪掉当前行5dd 减掉当前行起共5行D 剪空当前行(剪掉当前行的数据，变为空行)x 删除一个字母(向后删除一个字符)X 删除一个字母(向前删除一个字符)3x3Xdw 剪除一个单词 u|U撤销操作 12u 一次撤一行中的一个动作U 撤销一行中的所有动作 复制粘贴 12345yy 复制当前行5yy 复制5行p 粘贴(paste)ZZ 保存退出(新技能)ZQ 不保存退出(新技能) 大小写转换（依次执行命令） 123gg -&gt; gu -&gt; G 把选定范围全部小写gg -&gt; gU -&gt; G 把选定范围全部大写ggg -&gt; ~ -&gt; G 整篇文章反转(大转小小转大) 文件内容查找 1234567891011121314/word 从上而下在文件中查找字符串“word” ?word 从下而上在文件中查找字符串“word”n 定位下一个匹配的被查找字符串 N 定位上一个匹配的被查找字符串:set nu 显示行号:set nonu 不显示行号=======比如看日志：搜索某天某时的日志(新技能)/2016-02-16 14:..:..按下回车以后就可以搜索.按n可以查找下一个.按N可以查找上一个.另外可以输入:set hls去设置查找到的关键字高亮.搜索完毕要回到原来的输入地方只要按ctrl+o就可以了.. 替换 12:n,m/old/new/g 从第n行到第m行中，将old替换为new:n,$s/old/new/g 从第n行到最后一行中，将old替换为new 保存与退出 1234567:w 存盘不退出:w! 暴力存盘不退出:w file1 另存为file1:q 无脏数据时正常退出:q! 放弃脏数据并退出:wq 正常保存并退出:wq! 暴力存盘并退出 文件加密和解密 123456789------加密vim t.c 打开文件：X 据提示操作//加密: set key=password //加密作用同:X:wq 保存退出------解密------解密vim t.c 打开文件:set key= 解密:wq 保存退出]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[监控系统移动端接口文档]]></title>
      <url>%2F2016%2F06%2F09%2F%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%2F</url>
      <content type="text"><![CDATA[Welcome use ！ 监控系统移动端接口文档登陆12345url:/api/doLoginparams: loginName // 必须 password // 必须result: 1234成功：&#123;"data":[&#123;"page_size":50,"birthday":null,"role_id":110,"last_login_time":"2013-03-20 10:48:08","tel":null,"login_times":1,"unit_id":4,"last_login_ip":"192.168.0.103","password":"098f6bcd4621d373cade4e832627b4f6","username":"test","email":null,"address":null,"account":"test","gender":9,"user_id":7,"mobile":"13518744157"&#125;],"code":200,"msg":"成功"&#125;失败:&#123;"data":null,"code":400,"msg":"用户名密码错误"&#125; 信息处理12345678url:/api/infoProcessparams: userId // 必须 ids // 必须 &quot;1,2,3,4&quot; result // 必须 &quot;处理结果内容&quot; status // 必须 有效信息:2 误报信息:3result:&#123;&quot;data&quot;:null,&quot;code&quot;:200,&quot;msg&quot;:&quot;成功&quot;&#125; 意见反馈1234567url:/api/feedbackparams: userId // 必须 userName // 必须 content // 必须 &quot;意见内容&quot;result:&#123;&quot;data&quot;:null,&quot;code&quot;:200,&quot;msg&quot;:&quot;成功&quot;&#125; 检查版本123456url:/api/checkVersionForAndroidparams: v // 必须result:说明：code 1有更新 0无更新&#123;&quot;data&quot;:null,&quot;downloadUrl&quot;:&quot;http://115.28.224.10/lianzhong/android/维宝1.1.apk&quot;,&quot;code&quot;:1,&quot;msg&quot;:&quot;有新版本,请及时更新&quot;&#125; 信息列表1234567url:/api/infoListparams: page // 必须 1 2 3 rows // 必须 10 20 unitId // 非必须 用户所属联网单位Id 如果是管理员传空字符串 infoFlag // 必须 |报警信息类型(火警:01 故障:02 其他:04)result: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&#123; "data": [ &#123; "contactor": null, "info_content": "-2", "location": "传输装置", "manager_tel1": "18213023309", "tel": "0871-65527556", "manager_tel2": "13708413005", "legal_rep_name": "王晓根 0871-65412370", "device_num": "0001001001000000", "manager_name2": "黄少华 13708413005", "channel_num": "", "manager_name1": "闵学昆 18213023309", "regulatory_level": "0", "network_status": "1", "transmission_num": 1, "status_desc": "", "higher_unit": 0, "principal_idnum": "", "reply_time": null, "area_num": 1, "principal_name": "黄少华 13708413005", "alarm_time": "2015-11-23 06:54:50", "control_manuf_id": 21, "lower_unit": 0, "unit_num": 1, "status": "01", "regionName": "五华区", "org_code": "1", "address_num": 0, "transmission_id": 1, "manager_idnum1": "", "economic_type": "110", "manager_idnum2": "", "legal_rep_tel": "0871-65412370", "network_date": "2013-03-06 00:00:00", "center_process_result": null, "end_time": null, "postal_code": "650102", "pos_y": 0, "pos_x": 0, "unit_plan": "upload/unit_plan_4_131203170151.jpg", "region": "530102", "control_type_id": 11, "status_time": "1900-01-01 00:00:00", "device_type": "67", "loop_num": 0, "center_operator": null, "dvr_num": "", "lng": 102.674972, "unit_id": 4, "legal_rep_idnum": "", "facility_id": 5, "info_flag": "01", "principal_tel": "13708413005", "lat": 25.083782, "info_type": "01010100", "info_id": 16572519, "build_date": null, "device_id": 1, "reception_time": "2015-11-23 07:11:54", "fixed_asset": 0.0, "operator": 3, "staff_num": 0, "controlroom_tel": "65412370", "address": "昆明市五华区王家桥（云冶生活区）", "report_time": null, "confirm_result": null, "unit_type": "05", "building_area": 0.0, "unit_name": "云南云铜锌业经济适用住房", "process_result": "误报", "center_id": 1, "bg_img": "", "unit_outside_view": "upload/unit_outside_view_4_131203165420.jpg", "space_area": 6.541237E+7 &#125; ], "code": 200, "msg": "成功"&#125; 文章分页查询(企业网站使用)123456url:/api/postsparams: page // 非必须 1 2 3 默认1 rows // 非必须 10 20 默认10 postCategory // 非必须 文章类型 1:新闻 2:产品 默认2result: 文章详情1url:/api/post/&#123;id&#125; 返回说明12345678910111213public static final int success = 200;//成功public static final int exception = 500;//服务器出错public static final int error_loginNamePwd = 400;//用户名密码错误public static final int error_nullParams = 401;//有null参数public static final int success_hasNewVersion = 1;//public static final int success_noNewVersion = 0;//public static final String msg_success = "成功";public static final String msg_exception = "服务器出错";public static final String msg_error_loginNamePwd = "用户名密码错误";public static final String msg_error_nullParams = "有null或者\"\"参数";public static final String msg_hasNewVersion = "有新版本,请及时更新";public static final String msg_noNewVersion = "没有新版本"; 笔记： （unit_name + area_num + loop_num + address_num + location）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Redis统计活跃用户]]></title>
      <url>%2F2016%2F06%2F09%2F%E4%BD%BF%E7%94%A8Redis%E7%BB%9F%E8%AE%A1%E6%B4%BB%E8%B7%83%E7%94%A8%E6%88%B7%2F</url>
      <content type="text"><![CDATA[Welcome use ！ 使用Redis统计活跃用户用户登录后需要记录，以便以后进行登录统计 统计需求主要有： 今天的登录用户数 3天内都登录过的用户 7天内登录过的用户 常规解决方案: 如果不用redis，通常做法是在用户登录时记录日志，或者在数据库中添加一条登录记录 然后按照需求进行定时统计 redis解决方案 redis的 bit 操作非常适合处理这个场景 因为bit的值为 0或1，用户是否登录也可以用 0或1 来表示 我们把每天的用户登录信息记录到一个key中，值中的每个offset的值就是用户登录的标识 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960例如bit 基本操作示例（1）设置关键字的指定offset的值为 0 或 1 setbit key 100 1（2）bit运算例如key1 -&gt; 0101key2 -&gt; 0011and 运算 bitop and ret key1 key2就是对 key1 key2 各位进行 and 运算后赋值给 ret，结果为 0001or 运算 bitop or ret key1 key2就是对 key1 key2 各位进行 or 运算后赋值给 ret，结果为 0111（3）bit值为1的数量 bitcount key通过bit操作就可以实现用户统计的需求了例如今天为 2016-01-18把 key 定义为 userlogin:20160118（1）用户登录ID为 100 的用户登录了，执行 setbit userlogin:20160118 100 1（2）统计今天登录的用户数 bitcount userlogin:20160118（3）统计3天内都登录过的用户“都登录过”是要取得bit值都为1的，通过 and 计算获取 bitop or ret userlogin:20160116 userlogin:20160117 userlogin:20160118（4）统计7天内登录过的用户“登录过”表示bit值有一个为 1 即可，所以通过 or 计算获取命令与上一个类似－－－－以前统计的时候，还真没考虑bit操作，这算是一种新的思路。我该花点时间好好看看Redis了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Redis之过期键删除策略]]></title>
      <url>%2F2016%2F06%2F06%2FRedis%E4%B9%8B%E8%BF%87%E6%9C%9F%E9%94%AE%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%2F</url>
      <content type="text"><![CDATA[Welcome use ！ Redis之过期键删除策略如果一个键过期了，那么它什么时候会被删除呢？ 定时删除在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作 定时删除策略是对内存最友好的：通过使用定时器，定时删除策略可以保证过期键会尽可能快地被删除，并释放过期键所占用的内存。另一方面，定时删除策略的缺点是，它对CPU时间是最不友好的：在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间，在内存不紧张但是CPU时间非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。 例如，如果正有大量的命令请求在等待服务器处理，并且服务器当前不缺少内存，那么服务器应该优先将CPU时间用在处理客户端的命令请求上面，而不是用在删除过期键上面。 除此之外，创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式–无序链表，查找一个事件的时间复杂度为O(N) —- 并不能高效地处理大量时间事件。 因此，要让服务器创建大量的定时器，从而实现定时删除策略，在现阶段来说并不现实 惰性删除放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。 惰性删除策略对CPU时间来说是最友好的：程序只会在取出键时才对键进行过期检查，这可以保证删除过期键的操作只会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会在删除其他无关的过期键上花费任何CPU时间。 惰性删除策略的缺点是，它对内存是最不友好的：如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占的内存就不会释放。 在使用惰性删除策略时，如果数据库中有非常多的过期键，而这些过期键又恰好没有被访问到的话，那么它们也许永远也不会被删除（除非用户手动执行FLUSHDB），我们甚至可以将这种情况看作是一种内存泄露—-无用的垃圾数据占用了大量的内存，而服务器却不会自己去释放它们，这对于运行状态非常依赖于内存的Redis服务器来说，肯定不是一个好消息。 举个例子，对于一些和时间有关的数据，比如日志(log)，在某个时间之后，对它们的访问就会大大减少，甚至不再访问，如果这类过期数据大量地积压在数据库中，用户以为服务器已经自动将它们删除了，但实际上这些键仍然存在，而且键所占用的内存也没有释放，那么造成的后果肯定是非常严重的 定期删除每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。 定期删除策略是前两种策略的一种整合和折中 1234&gt;1. 定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响；&gt;&gt;2. 除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的内存浪费。&gt; 定期删除策略的难点是确定删除操作执行的时长和频率： 1234&gt; 1. 如果删除操作执行的太频繁，或者执行的时间太长，定期删除策略就会退化成定时删除策略，以至于将CPU时间过多地消耗在删除过期键上面。&gt;&gt; 2. 如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和惰性删除策略一样，出现浪费内存的情况。&gt; 因此，如果采用定期删除策略的话，服务器必须根据情况，合理地设置删除操作的执行时长和执行频率。 Redis服务器实际使用的是惰性删除和定期删除两种策略：通过配合使用这两种删除策略，服务器可以很好地在合理使用CPU时间和避免浪费内存空间之间取得平衡。简单说明下： 过期键的惰性删除策略由db.c/expireIfNeeded函数实现，所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查。过期键的定期删除策略由redis.c/activeExpireCycle函数实现，每当Redis的服务器周期性操作redis.c/serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[事务]]></title>
      <url>%2F2016%2F06%2F04%2F%E4%BA%8B%E5%8A%A1%2F</url>
      <content type="text"><![CDATA[数据库事务 事务Transaction Spring事务管理基于底层数据库本身的事务处理机制 数据库事务思想：要么所有执行success，不然就fail 目标：数据不会被破坏。即事务操作成功，数据的结果和业务期待的结果是一致的。这也就是ACID中的一致性（Consistency） ACID（原子性、一致性、隔离性和持久性）原子性原子是物质的最小单元，即不可再分。 1例如，以MySQL为例，每一个简单的 SQL 语句即包含在一个事务中，具有原子性；如果是多个sql则包含在一起实现更大的原子。 一致性终极目标：数据不会被破坏。具体说，事务操作成功后，数据库所处的状态和它的业务规则是一致的，即数据不会被破坏。举个栗子：两句UPDATE语句，从A账户转账到B账户，不管成功失败，A和B账户的总额是不变的。 隔离性表示互不干扰。事务与事务之间无法干扰，即每个事务独立，不会交叉。这样可以让多个线程并发访问数据库，但是聪明的小伙伴知道，如果事务完全隔离，每次只允许一个事务能访问数据库，那其他都是阻塞。会非常慢。这样会造成数据的并发问题。 隔离性中，事务并发访问的时候会出现：脏读、不可重复读和幻读 12345脏读:A事务读取了B事务未提交的更改数据。一般数据库事务默认不允许该问题出现不可重复读:A事务读取了B事务已提交的&quot;更改数据&quot;(行级锁)幻读:A事务读取了B事务提交的&quot;新增数据&quot;(表锁定)重复读和幻读区别：一个更改，一个新增数据。其实两个区别在于一个是新增（insert语句），处理幻读这个操作需要加表级别的锁，将整个表锁定，防止新增数据造成幻读。另一个则是更改（update delete），这时候避免这个情况只需要添加行级锁组织该行发生变化即可 事务隔离级别 1既要求高的隔离性（安全性），又要求高并发性。这种是不可能的任务。根据各种锁的操作机制出现了一个事务隔离级别。即相同情况下的输入，不同隔离级别结果不同。为啥了，当然是在并发性和安全性的抉择。 Level 脏读 不可重复读 幻读 read_uncommitted Y Y Y read_committed N Y Y repeatable_read N N Y serializable N N N 总结:根据程序的并发性和安全性的抉择。鱼和熊掌不可兼得也~ 但分布式的时候，可以把安全性关键的单独分布式锁。 持久性数据必须持久化到数据库（存储在磁盘）中。已提交的事务，即使在提交后数据库崩溃，重启数据库时也能够根据日志对未持久化的数据进行重执行操作。 小结：数据的一致性是最终目标，其他特性都是其要求或手段。 JDBC事务实战1234567891011121314151617181920212223242526272829303132333435public class TransactionLevels extends BaseJDBC &#123; public static void main(String[] args) &#123; try &#123; // 加载数据库驱动 Class.forName(DRIVER); // 数据库连接 Connection conn = DriverManager.getConnection(URL,USER,PWD); // 数据库元数据 DatabaseMetaData metaData = conn.getMetaData(); // 是否支持事务 boolean isSupport = metaData.supportsTransactions(); System.out.println(isSupport); // 是否支持的事务 boolean isSupportLevel = metaData.supportsTransactionIsolationLevel(Connection.TRANSACTION_SERIALIZABLE); System.out.println(isSupportLevel); // 获取默认事务 int defaultIsolation = metaData.getDefaultTransactionIsolation(); //这里可以看出MySQL默认支持的事务级别是 READ_COMMITTED，默认会隔离脏读 System.out.println(defaultIsolation); /** 关闭数据库连接 */ if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 总结因此在安全性要求不高，支持高并发的情况下，选择MySQL默认事务等级(READ_COMMITTED)。但在安全性极高，几乎不会出现高并发情况下，选择更高的事务等级]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面试总结-持续更新]]></title>
      <url>%2F2016%2F06%2F04%2F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%2F</url>
      <content type="text"><![CDATA[近期公司出了些状况,总结下这几天的面试体验。有些问题单独写了md。 session共享1,Session复制 各个服务器之间同步复制 2,Session绑定 负载IPHash设置 3,利用Cookie记录Session 4,Session服务器，Redis集群管理Session mybatis 原理MyBatis应用程序根据XML配置文件创建SqlSessionFactory，SqlSessionFactory在根据配置，配置来源于两个地方，一处是配置文件，一处是Java代码的注解，获取一个SqlSession。SqlSession包含了执行sql所需要的所有方法，可以通过SqlSession实例直接运行映射的sql语句，完成对数据的增删改查和事务提交等，用完之后关闭SqlSession。 mybatis批量插入大数据量程序中分批插入，Mapper.xml中用 foreach 拼装批量插入的sql。 mybatis分页原理mybatis拦截器 springMVC 原理1、客户端发出一个http请求给web服务器，web服务器对http请求进行解析，如果匹配DispatcherServlet的请求映射路径（在web.xml中指定），web容器将请求转交给DispatcherServlet. 2、DipatcherServlet接收到这个请求之后将根据请求的信息（包括URL、Http方法、请求报文头和请求参数Cookie等）以及HandlerMapping的配置找到处理请求的处理器（Handler）。 3-4、DispatcherServlet根据HandlerMapping找到对应的Handler,将处理权交给Handler（Handler将具体的处理进行封装），再由具体的HandlerAdapter对Handler进行具体的调用。 5、Handler对数据处理完成以后将返回一个ModelAndView()对象给DispatcherServlet。 6、Handler返回的ModelAndView()只是一个逻辑视图并不是一个正式的视图，DispatcherSevlet通过ViewResolver将逻辑视图转化为真正的视图View。 7、Dispatcher通过model解析出ModelAndView()中的参数进行解析最终展现出完整的view并返回给客户端 springMVC视图解析原理]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[FOR UPDATE的使用]]></title>
      <url>%2F2016%2F06%2F01%2FFOR%20UPDATE%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[Welcome read ！ 针对并发，目前一个通用的做法有两种：锁机制：1.悲观锁；2.乐观锁 利用select * for update 可以锁表/锁行。自然锁表的压力远大于锁行。所以我们采用锁行。什么时候锁表呢？ 假设有个表单products ，里面有id跟name二个栏位，id是主键。例1: (明确指定主键，并且有此笔资料，row lock)SELECT FROM wallet WHERE id=’3′ FOR UPDATE;例2: (明确指定主键，若查无此笔资料，无lock)SELECT FROM wallet WHERE id=’-1′ FOR UPDATE;例2: (无主键，table lock)SELECT FROM wallet WHERE name=’Mouse’ FOR UPDATE;例3: (主键不明确，table lock)SELECT FROM wallet WHERE id&lt;&gt;’3′ FOR UPDATE;例4: (主键不明确，table lock)SELECT * FROM wallet WHERE id LIKE ‘3’ FOR UPDATE; tomcat配置： 第1种方式：配置ConnectormaxThreads：tomcat可用于请求处理的最大线程数minSpareThreads：tomcat初始线程数，即最小空闲线程数maxSpareThreads：tomcat最大空闲线程数，超过的会被关闭acceptCount：当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数的请求将不予处理 1&lt;Connectorport="8080"maxHttpHeaderSize="8192"maxThreads="150"minSpareThreads="25"maxSpareThreads="75"enableLookups="false"redirectPort="8443"acceptCount="100"connectionTimeout="20000"disableUploadTimeout="true"/&gt; 第2种方式：配置Executor和Connector name：线程池的名字class：线程池的类名namePrefix：线程池中线程的命名前缀maxThreads：线程池的最大线程数minSpareThreads：线程池的最小空闲线程数maxIdleTime：超过最小空闲线程数时，多的线程会等待这个时间长度，然后关闭threadPriority：线程优先级 123&lt;Executorname="tomcatThreadPool"namePrefix="req-exec-"maxThreads="1000"minSpareThreads="50"maxIdleTime="60000"/&gt;&lt;Connectorport="8080"protocol="HTTP/1.1"executor="tomcatThreadPool"/&gt; 参考链接]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[高性能架构]]></title>
      <url>%2F2016%2F06%2F01%2F%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%2F</url>
      <content type="text"><![CDATA[Welcome use ！ 网站性能指标：响应时间，吞吐量 测试指标：响应时间，并发数，吞吐量（TPS QPS），性能计数器 前端架构优化手段，通过优化页面HTML样式，利用浏览器的并发和异步特性，调整浏览器缓存策略，使用CDN服务，反向代理等手段。 缓存加快数据读取，集群提高吞吐能力，异步消息加快请求响应及实现削峰 建设优化骨干网，使用高性能服务器 前端优化 减少HTTP请求:合并css,合并js，合并图片 使用浏览器缓存：HTTP头 Cache-Control 和 Expires 启用压缩：HTML CSS JS — GZip css 放在页面上面 js放在页面下面 减少Cookie传输 系统上层缓存 ，集群，异步 缓存服务器、集群部署、异步-&gt;消息队列服务器]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[服务化架构演进]]></title>
      <url>%2F2016%2F05%2F29%2F%E6%9C%8D%E5%8A%A1%E5%8C%96%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%2F</url>
      <content type="text"><![CDATA[Welcome use ！ 服务化架构演进ORM-&gt;MVC-&gt;RPC-&gt;SOA orm-单一应用架构是一个高内聚版本，所有功能部署在一起。数据访问框架（orm）成为关键。这个架构很少被人使用，几乎接近灭绝了吧。优点：成本低，适合功能少又简单缺点：很多，比如无法适应高流量，二次开发难，部署成本高 mvc架构 － 垂直应用架构当访问量渐渐增大，慢慢演化成用的很多的mvc架构。虽然还是所有的功能都是部署在同一个进程中，但是可以通过双机或者前置负载均衡来实现负载分流。这样应用也可以拆分成不同的几个应用，以提升性能和效率。此时，mvc架构用于分离前后端逻辑。一方面，有一定的模块化。另一方面，加速和方便了开发。 rpc架构 － 分布式服务架构当mvc垂直应用分成不同应用时，越来越多的情况下。不可避免的事应用a与应用b之间的交互。此时将核心和公共的 业务功能抽出来，作为单独的服务，并实现前后端逻辑分离。此时则就需要提高业务的复用及整合的分布式rpc框架，例如dubbo等。 soa架构 － 流动计算架构当rpc架构中的服务越来越多时，服务的生命周期的管控，容量的评估等各种问题会出现，使服务化成为瓶颈。需要增加一个调度中心来进行对服务管控，监督等。 微服务架构它就是将功能分散到各个离散的服务中然后实现对方案的解耦。服务更原子，自治更小，然后高密度部署服务。 松耦合，功能在不同微服务的进程中，基于独立服务，按需扩展]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[多线程]]></title>
      <url>%2F2016%2F05%2F28%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[Welcome use ！ 多线程Jdk1.5之后加入了java.util.concurrent包。 线程池作用：就是限制系统中执行线程的数量 1.减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 2.可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。 核心类： ExecutorService 真正的线程池接口 ScheduledExecutorService 能和Timer/TimerTask类似，解决那些需要任务重复执行的问题。 ThreadPoolExecutor ExecutorService的默认实现 ScheduledThreadPoolExecutor 继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。 ThreadPoolExecutor详解123456789101112//完整的构造方法/**corePoolSize - 池中所保存的线程数，包括空闲线程。maximumPoolSize-池中允许的最大线程数。keepAliveTime - 当线程数大于核心时，此为 终止前 多余的空闲线程 等待新任务 的 最长时间。unit - keepAliveTime 参数的时间单位。workQueue - 执行前用于保持任务的队列。此队列仅保持由 execute方法提交的 Runnable任务。threadFactory - 执行程序创建新线程时使用的工厂。handler - 由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序。ThreadPoolExecutor是Executors类的底层实现 */ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 四种线程池，Java通过Executors提供四种线程池 线程池 特点 注意 newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待 但在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源 newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行 newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行 newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程 一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪 12345678910111213141516public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125;public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 多线程案例1.多线程异步下载 ​ 在做报表系统的时候，各个部门的报表数据，有提供 下载 报表数据的功能，由于部门很多，或者报表数据很大，为了不耽误工作人员等待下载的时间，实现多线程异步下载，把下载任务添加到线程池中，当任务完成，下载完毕。工作人员去自己的任务中心或者通知中心查看下载状态，如果完成，去相应的地方找到自己的报表即可。 2.多线程爬虫 ​ 在做爬虫系统的时候，一个定时任务启动时候，可能会有很多爬虫进行并发爬取，我们采用线程池+队列的方法控制这个时间段的爬虫数据，保证系统不出现内存溢出或者服务器宕机的状况。 线程监控Jdk自带 bin\jconsole.exe http://dl.iteye.com/upload/picture/pic/129496/a37b1415-36ac-30b8-baf6-10897bbf443a.jpg http://dl.iteye.com/upload/picture/pic/129498/c518b086-b144-366c-884c-58a4bf985b05.jpg 参考链接]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux 安装jdk1.7]]></title>
      <url>%2F2016%2F05%2F28%2Flinux%E5%AE%89%E8%A3%85jdk1.7%2F</url>
      <content type="text"><![CDATA[Welcome read ！ 下载 jdk712$ cd /app/jdk/jdk7/$ wget --no-check-certificate --no-cookies --header &quot;Cookie: oraclelicense=accept-securebackup-cookie&quot; http://120.52.72.24/download.oracle.com/c3pr90ntc0td/otn-pub/java/jdk/7u79-b15/jdk-7u79-linux-x64.tar.gz jdk7官方网站 解压12$ sudo tar zxvf ./jdk-7u79-linux-x64.tar.gz$ tar zxvf ./jdk-7u79-linux-x64.tar.gz 配置环境变量123456789$ vim /etc/profile新增配置:export JAVA_HOME=/app/jdk/jdk7/jdk1.7.0_79export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$JAVA_HOME/bin:$PATH$ source /etc/profile$ java -version tomcat rs.sh123456export JAVA_HOME=&apos;/app/jdk/jdk7/jdk1.7.0_79&apos;ps -ef |grep tomcat |awk &apos;&#123;print $2&#125;&apos;|xargs kill -9echo &quot;tomcat shutdown!!&quot;sleep 0.5/app/tomcat/apache-tomcat-7.0.63/bin/catalina.sh startecho &quot;restart ok!!&quot;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[gitbook install and work]]></title>
      <url>%2F2016%2F05%2F27%2Fgitbook-install-and%20work%2F</url>
      <content type="text"><![CDATA[Welcome read ！ How to install it?123$ npm install -g gitbook$ npm install -g gitbook-cli Test installed.1$ gitbook help Often use shell.1234567$ gitbook init //init book dir$ gitbook serve //start server and view --&gt; http://localhost:4000$ gitbook build: 会生成相应的 HTML 文件供分发。$ gitbook pdf: 生成 PDF 文件$ gitbook epub: 生成 epub 文件$ gitbook mobi: 生成 mobi 文件 Gitbook init首先，通过终端(PC 下可使用命令提示符)进入到你想要书写内容的目录，然后执行 gitbook init 命令，之后目录中会自动生成 README.md 和 SUMMARY.md 两个文件。这两个文件在 GitBook 项目中是必须存在的，其中 README.md 是对书籍的简单介绍，SUMMARY.md 是对书籍目录的描述，并且 GitBook 会通过该文件中的目录描述自动生成对应的目录和文件。 其中，SUMMARY.md 文件中内容的格式是这样的: 1234* [Chapter1](chapter1/README.md) * [Section1.1](chapter1/section1.1.md) * [Section1.2](chapter1/section1.2.md)* [Chapter2](chapter2/README.md) 当你修改了 SUMMARY.md 文件中的内容后，你可以再次使用 gitbook init 来自动生成对应的目录和文件。 Multi-Languages如果你要写的书籍是多语言版，你只需要创建一个 LANGS.md 文件，然后编写配置内容即可: 123* [English](en/)* [French](fr/)* [Español](es/) Gitbook serve书籍目录结构创建完成以后，我们就可以使用 gitbook serve 来编译和预览书籍了： gitbook serve 命令实际上会首先调用 gitbook build 编译书籍，完成以后会打开一个 web 服务器，监听在本地的 4000 端口。 Install plus12$ gitbook install disqus$ gitbook install multipart 参考链接]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[非洲旅游App接口说明]]></title>
      <url>%2F2016%2F05%2F27%2F%E9%9D%9E%E6%B4%B2%E6%97%85%E6%B8%B8App%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E%2F</url>
      <content type="text"><![CDATA[Welcome use ！ iphttp://readshe.com/fast 登陆(Post)12345url:/api/doLoginparams: loginName //必须 password //必须result: 动物、植物、鸟类展示列表(Post)12345678url:/api/objectsListparams: types //必须 &quot;animal&quot; or &quot;animal,bird&quot; or &quot;animal,bird,plant&quot; name //cnName or enName orderBy //&quot;rareLeavel desc&quot; or &quot;rareLeavel asc&quot; 稀有程度排序 page // 1 or 2 or 3 从1开始 rows //10result: 动物、植物、鸟类详情(Post)1234url:/api/objectsDetailparams: id //必须result: 国家列表(Post)123456url:/api/countryListparams: page //必须 1 or 2 or 3 从1开始 rows //必须 10 name_string_like // &quot;肯尼亚Kenya&quot;result: 景点列表(Post)123456url:/api/placeListparams: page //必须 1 or 2 or 3 从1开始 rows //必须 10 cnName-enName_string_like // &quot;内罗毕&quot;result: 故事列表(Post)123456url:/api/storyListparams: page //必须 1 or 2 or 3 从1开始 rows //必须 10 name_string_like // &quot;绿带运动&quot;result: 酒店列表(Post)123456url:/api/hotelListparams: page //必须 1 or 2 or 3 从1开始 rows //必须 10 cnName-enName_string_like // &quot;东方钻石星酒店&quot;result: 行程列表123url:/api/planListparams:nullresult: 我的行程1234url:/api/myPlanparams: planId //必须，这个planId是用户登录之后从用户信息里面取出result: 收藏1234567url:/api/collectparams: name //必须|收藏标题，比如收藏的某个景点名称 userId //必须 tableName //必须|&quot;objects&quot;,&quot;place&quot;,&quot;country&quot;,&quot;story&quot;,&quot;hotel&quot; tableId //必须 | 比如收藏的某个景点的idresult: 收藏列表1234567url:/api/collectListparams: page //必须 1 or 2 or 3 从1开始 rows //必须 10 userId_long_eq //必须 |用户ID name_string_like //&quot;东方钻石星酒店&quot;result: 分享1234567url:/api/shareparams: name //必须|分享标题，比如分享的某个景点名称 userId //必须 tableName //必须|&quot;objects&quot;,&quot;place&quot;,&quot;country&quot;,&quot;story&quot;,&quot;hotel&quot; tableId //必须 | 比如分享的某个景点的idresult: 分享列表1234567url:/api/planListparams: page //必须 1 or 2 or 3 从1开始 rows //必须 10 userId_long_eq //必须 |用户ID name_string_like //&quot;东方钻石星酒店&quot;result: 全文搜索1234url:/api/searchparams: keyWord //必须 | 搜索5张表的数据 (&quot;objects&quot;,&quot;place&quot;,&quot;country&quot;,&quot;story&quot;,&quot;hotel&quot;)result:如下结构 1&#123;"code":200,"msg":"成功","data":&#123;"story":[],"hotel":[],"place":[],"objects":[],"country":[]&#125;&#125; 详情|通用12345url:/api/viewparams: tableName //必须 | 支持5张表 (&quot;objects&quot;,&quot;place&quot;,&quot;country&quot;,&quot;story&quot;,&quot;hotel&quot;) tableId //必须result:如下结构 返回码说明1234567891011public static final int success = 200;//成功public static final int exception = 500;//服务器出错public static final int error_loginNamePwd = 400;//用户名密码错误public static final int error_nullParams = 401;//有null参数public static final int error_tableName = 402;//tableName参数错误public static final String msg_success = "成功";public static final String msg_exception = "服务器出错";public static final String msg_error_loginNamePwd = "用户名密码错误";public static final String msg_error_nullParams = "有null或者\"\"参数";public static final String msg_error_tableName = "tableName参数错误";]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[新闻后台接口]]></title>
      <url>%2F2016%2F05%2F27%2F%E6%96%B0%E9%97%BB%E5%90%8E%E5%8F%B0%E6%8E%A5%E5%8F%A3%2F</url>
      <content type="text"><![CDATA[Welcome use ！ 分类接口（Get|Post）1234567url:http://readshe.com/api/post/categoriesparams:nullreturn: [&#123;"id":8,"value":"社会"&#125;, &#123;"id":9,"value":"股市"&#125;, &#123;id":13,"value":"科技"&#125;, &#123;"id":14,"value":"证券"&#125;] 新闻列表（Post）123456url:http://readshe.com/api/post/listparams: category,string,eq=9 //分类id page=1 //页码 rows=10 //每页条数return:如下 123456789101112131415161718192021222324252627282930313233343536373839404142&#123; "lastPage": false,//忽略 "pageSize": 20,//忽略 "pageNumber": 1,//忽略 "firstPage": true,//忽略 "list": [ &#123; "icon": null, "module": "A", "desc": "呼和浩特5月12日电(张林虎)俗话说，虎毒不食子", "status": "0", "code": null, "id": 20470, "publicTime": "2016-05-12 16:13", "content": "...", "author": null, "title": "27岁母亲杀害1岁亲生子称不后悔 患有精神分裂", "category": "8", "source": "新浪", "address": "http://news.sina.com.cn/c/2016-05-12/doc-ifxsehvu8791685.shtml", "fetchTime": "2016-05-13 16:40:09" &#125;, &#123; "icon": "http://n.sinaimg.cn/news/transform/20160404/EtTh-fxqxcnp8540722.png", "module": "A", "desc": "宋仲基被印冥币上", "status": "0", "code": null, "id": 20489, "publicTime": "2016-04-04 21:24 -", "content": "...", "author": null, "title": "宋仲基被印上冥币遭网友调侃：“送终鸡”(图)", "category": "8", "source": "新浪", "address": "http://news.sina.com.cn/s/wh/2016-04-04/doc-ifxqxcnp8540724.shtml", "fetchTime": "2016-05-13 19:50:06" &#125; ], "totalRow": 427, "totalPage": 22&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[集群部署Session共享Redis解决方案]]></title>
      <url>%2F2016%2F05%2F26%2Ftomcat7-redis-%E5%AD%98%E5%82%A8session%2F</url>
      <content type="text"><![CDATA[Welcome read ！ tomcat7 redis 存储session链接一 链接二 使用redis的SessionManager实现多个Tomcat实例Session共享 准备工作安装tomcat 安装redis 添加jar包添加jar包到每一个tomcat实例的lib目录下 1234commons-pool2-2.2.jarjedis-2.8.1.jartomcat-juli-7.0.54.jartomcat-redis-session-manager1.2.jar jar包链接 密码：bwuy tomcat配置文件context.xml修改每个tomcat实例的context.xml文件 12345678# vim conf/context.xml &lt;Valve className=&quot;com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve&quot; /&gt; &lt;Manager className=&quot;com.orangefunction.tomcat.redissessions.RedisSessionManager&quot; host=&quot;192.168.1.101&quot; port=&quot;6379&quot; password=&quot;redis&quot; database=&quot;0&quot; maxInactiveInterval=&quot;60&quot;/&gt; 测试编写session.jsp测试文件，使其能通过tomcat访问 123456789101112131415161718192021&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;236&lt;%=request.getSession(true).getAttribute("name")%&gt;&lt;br&gt;&lt;%=request.getSession(true).getId()%&gt;&lt;br&gt;&lt;%=request.getSession(true).getAttribute("vcode")%&gt;&lt;br&gt;&lt;%=request.getSession(true)%&gt;&lt;br&gt;&lt;%=request%&gt;&lt;/body&gt;&lt;/html&gt; 启动多个tomcat，访问session.jsp，session_id相同。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Redis安装]]></title>
      <url>%2F2016%2F05%2F23%2FRedis%E5%AE%89%E8%A3%85%2F</url>
      <content type="text"><![CDATA[Welcome use ！ 1234567891011121314151617$ wget http://download.redis.io/releases/redis-2.8.17.tar.gz$ tar zxvf redis-2.8.17.tar.gz$ cd redis-2.8.17/$ make ## 编译$ sudo cp redis.conf /etc/ ## 拷贝配置和启动命令到快捷目录$ cd src/ ## 启动命令在src目录$ sudo cp redis-benchmark redis-cli redis-server /usr/bin/## Redis配置设置$ vim /etc/redis.conf## 将 daemonize 从 no 修改成 yes，运行为了守护进程。##（ps：vim 搜索文本 esc — :/daemonize）## 启动Redis$ redis-server /etc/redis.conf## 验证$ ps -ef | grep redis$ redis-cli$ ping ## response &apos;pong&apos; 集群部署TODO]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[报警监控后台管理系统]]></title>
      <url>%2F2016%2F02%2F28%2Fnbst%2F</url>
      <content type="text"><![CDATA[Welcome read ！ 报警监控后台管理系统 功能模块1、系统管理用户管理1增删改查 菜单管理1增删该查 角色管理1增删改查 权限管理1增删改查、分配权限、查看权限 2、监控中心管理监控中心列表1增删改查 监控人员列表1增删改查 3、联网单位管理单位列表1增删改查 单位联系人列表1增删改查(安全责任人|安全管理人|消防管理人) 4、建筑物管理1增删改查 5、重点部位管理1增删改查 6、消防设施管理（ ？） [ ] 消防设施主要是干什么的？ [ ] 关联那部分数据？ 1增删改查 7、传输设备管理 [ ] 传输设备点名是什么意思？ 1增删该查 8、设施部件管理1增删该查 设施检查管理1增删该查 设施维护管理1增删该查 9、查岗信息管理（需要？）1增删改查 10、控制器管理厂家管理1增删改查 型号管理1增删改查 11、消防管理法规管理1增删改查 常识管理1增删改查 12、报警信息管理报警信息12查询筛选火警、故障、其他信息受理、删除、查询 有效信息12查询筛选火警、故障、其他信息删除 误报信息12查询筛选火警、故障、其他信息删除 13、统计查询管理综合查询按区域统计1展示图表 按单位统计1展示图表 14、数据字典管理行政区域中心级别单位类别经济所有制监管等级业务说明12345678910111213141516171819主要逻辑关系:监控中心、联网单位、建筑物、重点部位、传输设备、设施部件一个监控中心 联网单位1 建筑物1(传输设备1) 重点部位1(设施部件1) 重点部位2(设施部件2) ... 建筑物2(传输设备2) 重点部位3(设施部件3) 重点部位4(设施部件4) ... 联网单位2 建筑物3 建筑物4应用场景： 当一个设施部件1发生报警，会将报警信息传输给传输设备1，传输设备1将报警信息传输给监控中心，并存到数据库发出报警。 数据库1、系统表(tsys)2、字典表(tdict)3、业务表(tyw)gb26875-2011参考后台系统http://123.56.79.107/nbst/index.action]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js正则判断车牌号码]]></title>
      <url>%2F2015%2F12%2F07%2Fjs%E6%AD%A3%E5%88%99%E5%88%A4%E6%96%AD%E8%BD%A6%E7%89%8C%E5%8F%B7%E7%A0%81%2F</url>
      <content type="text"><![CDATA[JS校验车牌号 1.常规车牌号：仅允许以汉字开头，后面可录入六个字符，由大写英文字母和阿拉伯数字组成。如：粤B12345； 2.武警车牌：允许前两位为大写英文字母，后面可录入七个字符，由大写英文字母和阿拉伯数字组成，其中第三位可录汉字也可录大写英文字母及阿拉伯数字，如：WJ01警0081、WJ0112345。 3.最后一个为汉字的车牌：允许以汉字开头，后面可录入六个字符，前五位字符，由大写英文字母和阿拉伯数字组成，而最后一个字符为汉字，汉字包括“挂”、“学”、“警”、“军”、“港”、“澳”。如：粤Z1234港。 4.新军车牌：以两位为大写英文字母开头，后面以5位阿拉伯数字组成。如：BA12345。 5.黑龙江车牌存在08或38开头的情况 123function isLicenseNo(str) &#123; return /(^[\u4E00-\u9FA5]&#123;1&#125;[A-Z0-9]&#123;6&#125;$)|(^[A-Z]&#123;2&#125;[A-Z0-9]&#123;2&#125;[A-Z0-9\u4E00-\u9FA5]&#123;1&#125;[A-Z0-9]&#123;4&#125;$)|(^[\u4E00-\u9FA5]&#123;1&#125;[A-Z0-9]&#123;5&#125;[挂学警军港澳]&#123;1&#125;$)|(^[A-Z]&#123;2&#125;[0-9]&#123;5&#125;$)|(^(08|38)&#123;1&#125;[A-Z0-9]&#123;4&#125;[A-Z0-9挂学警军港澳]&#123;1&#125;$)/.test(str); &#125; hello]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sublime Text 3破解]]></title>
      <url>%2F2015%2F11%2F12%2FSublime-Text-3%E7%A0%B4%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[另外分享一大波现在可以使用的Sublime Text 3序列号 ----- BEGIN LICENSE ----- Michael Barnes Single User License EA7E-821385 8A353C41 872A0D5C DF9B2950 AFF6F667 C458EA6D 8EA3C286 98D1D650 131A97AB AA919AEC EF20E143 B361B1E7 4C8B7F04 B085E65E 2F5F5360 8489D422 FB8FC1AA 93F6323C FD7F7544 3F39C318 D95E6480 FCCC7561 8A4A1741 68FA4223 ADCEDE07 200C25BE DBBC4855 C4CFB774 C5EC138C 0FEC1CEF D9DCECEC D3A5DAD1 01316C36 ------ END LICENSE ------ ----- BEGIN LICENSE ----- Free Communities Consultoria em Informática Ltda Single User License EA7E-801302 C154C122 4EFA4415 F1AAEBCC 315F3A7D 2580735A 7955AA57 850ABD88 72A1DDD8 8D2CE060 CF980C29 890D74F2 53131895 281E324E 98EA1FEF 7FF69A12 17CA7784 490862AF 833E133D FD22141D D8C89B94 4C10A4D2 24693D70 AE37C18F 72EF0BE5 1ED60704 651BC71F 16CA1B77 496A0B19 463EDFF9 6BEB1861 CA5BAD96 89D0118E ------ END LICENSE ------ ----- BEGIN LICENSE ----- Nicolas Hennion Single User License EA7E-866075 8A01AA83 1D668D24 4484AEBC 3B04512C 827B0DE5 69E9B07A A39ACCC0 F95F5410 729D5639 4C37CECB B2522FB3 8D37FDC1 72899363 BBA441AC A5F47F08 6CD3B3FE CEFB3783 B2E1BA96 71AAF7B4 AFB61B1D 0CC513E7 52FF2333 9F726D2C CDE53B4A 810C0D4F E1F419A3 CDA0832B 8440565A 35BF00F6 4CA9F869 ED10E245 469C233E ------ END LICENSE ------ ----- BEGIN LICENSE ----- Anthony Sansone Single User License EA7E-878563 28B9A648 42B99D8A F2E3E9E0 16DE076E E218B3DC F3606379 C33C1526 E8B58964 B2CB3F63 BDF901BE D31424D2 082891B5 F7058694 55FA46D8 EFC11878 0868F093 B17CAFE7 63A78881 86B78E38 0F146238 BAE22DBB D4EC71A1 0EC2E701 C7F9C648 5CF29CA3 1CB14285 19A46991 E9A98676 14FD4777 2D8A0AB6 A444EE0D CA009B54 ------ END LICENSE ------ ----- BEGIN LICENSE ----- Alexey Plutalov Single User License EA7E-860776 3DC19CC1 134CDF23 504DC871 2DE5CE55 585DC8A6 253BB0D9 637C87A2 D8D0BA85 AAE574AD BA7D6DA9 2B9773F2 324C5DEF 17830A4E FBCF9D1D 182406E9 F883EA87 E585BBA1 2538C270 E2E857C2 194283CA 7234FF9E D0392F93 1D16E021 F1914917 63909E12 203C0169 3F08FFC8 86D06EA8 73DDAEF0 AC559F30 A6A67947 B60104C6 ------ END LICENSE ------ ----- BEGIN LICENSE ----- Peter Halliday Single User License EA7E-855988 3997BFF0 2856413A 7A555954 67069B78 06D8CE12 63EAF079 AD039757 79E16D13 C555AD90 465CBE53 10F6DFC4 D3A3C611 411106F8 0CFEB15F 0A7BB891 111F5ED2 C6AA8429 77913528 FA6291A9 B88D4550 F1D6AB13 BF9153BC 91B4DFFE D296CFE0 C1D8EB22 13D5F14E 75A699EC 49EDDC23 D89D0F9B D240B10A A3712467 09DE7870 ------ END LICENSE ------ ----- BEGIN LICENSE ----- Fred Zirdung Single User License EA7E-844672 6089C0EC 22936E1A 1EADEBE2 B8654BBA 5C98FFA6 C0FD1599 0364779B 071C74FB EEFE9EAB 92B3D867 CD1B32FE D190269F 6FC08F8F 8D24191D 32828465 942CE58E AECE5307 08B62229 D788560A 6E0AAC4B 48A2D9EE 24FD8CAA 07BEBDF2 28EA86D4 CCB96084 6C34CAD2 E8A04F39 3B5A3CBC 3B668BB7 C94D0B4B 847D6D7F 4BC07375 ------ END LICENSE ------ ----- BEGIN LICENSE ----- Wixel Single User License EA7E-848235 103D2969 8700C7ED 8173CF61 537000C0 EB3C7ECB 5E750F17 6B42B67C A190090B 7669164F C6F371A8 5A1D88D5 BDD0DA70 C065892B 7CC1BB2B 1C8B8C7C F08E7789 7C2A5241 35F86328 4C8F70D9 C023D7C2 11245C36 59A730DB 72BDB9A7 D5B20304 90E90E72 9F08CA25 73F49C20 179D938E 5BC8BEDA 13457A69 39E6265F 233767F9 ------ END LICENSE ------ ----- BEGIN LICENSE ----- Daniel Russel Single User License EA7E-917420 9327EC62 44020C2A 45172A68 12FE13F1 1D22245B 680892EE F551F8EB C183D032 8B4EDB4B 479CB7E4 07E42EDD A780021D 56BADF42 AC05238B 023B47B1 EBA1B7DE 6DF9A383 159F32AE 04EBE100 1278B1D2 52E81B60 C68AA2E8 F84A20BE FE7990EB 5D44E4B6 16369263 1DDAACBC 280FF19E 86CF4319 0B8615A8 4FF0512E B123B8EC ------ END LICENSE ------ ----- BEGIN LICENSE ----- Peter Eriksson Single User License EA7E-890068 8E107C71 3100D6FC 2AC805BF 9E627C77 72E710D7 43392469 D06A2F5B F9304FBD F5AB4DB2 7A95F172 FE68E300 42745819 E94AB2DF C1893094 ECABADC8 71FEE764 20224821 3EABF931 745AF882 87AD0A4B 33C6E377 0210D712 CD2B1178 82601542 C7FD8098 F45D2824 BC7DFB38 F1EBD38A D7A3AFE0 96F938EA 2D90BD72 9E34CDF0 ------ END LICENSE ------ ----- BEGIN LICENSE ----- Ryan Clark Single User License EA7E-812479 2158A7DE B690A7A3 8EC04710 006A5EEB 34E77CA3 9C82C81F 0DB6371B 79704E6F 93F36655 B031503A 03257CCC 01B20F60 D304FA8D B1B4F0AF 8A76C7BA 0FA94D55 56D46BCE 5237A341 CD837F30 4D60772D 349B1179 A996F826 90CDB73C 24D41245 FD032C30 AD5E7241 4EAA66ED 167D91FB 55896B16 EA125C81 F550AF6B A6820916 ------ END LICENSE ------]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java 正则表达式]]></title>
      <url>%2F2015%2F10%2F27%2Fjava-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[.句点符号匹配所有字符，包括空格、Tab字符甚至换行符 . 条件限制除/n以外任意一个单独字符 表达式 匹配 t.n tan、tbn、t#n、t n java.. 条件限制为java后除换行外任意两个字符 []方括号之内只能匹配单个字符 表达式 匹配 t[aeio]n tan、ten、tin、ton |如果除了上面匹配的所有单词之外，你还想要匹配“toon”，那么，你可以使用“|”操作符。“|”操作符的基本意义就是“或”运算。要匹配“toon”，使用“t(a|e|i|o|oo)n”正则表达式。这里不能使用方扩号，因为方括号只允许匹配单个字符；这里必须使用圆括号“()”。圆括号还可以用来分组，具体请参见后面介绍。 t(a|e|i|o|oo)n tan、ten、tin、ton、toon 次数 表达式 匹配 * 0 or more次 + 1 or more次 ? o or 1次 {n} n次 {n,m} 从n到m次 999-99-9999 [0-9]{3} \- [0-9]{2} \- [0-9]{4} 999-99-9999和999999999 [0-9]{3} \-? [0-9]{2} \-? [0-9]{4} ^“^”符号称为“否”符号。如果用在方括号内，“^”表示不想要匹配的字符 [^X][a-z]+ ^为限制开头 ^java 条件限制为以Java为开头字符 $为限制结尾 java$ 条件限制为以java为结尾字符 ()和空白符号 \s假设要从格式为“June 26, 1951”的生日日期中提取出月份部分 匹配所有Moth DD,YYYY格式的日期 [a-z]+ \s+ [0-9]{1,2}, \s* [0-9]{4} --- --- 必选空格 可选空格 常用字符 符号 等价正则 \d [0-9] \D [^0-9] \w [a-zA-Z_0-9] \W [^a-zA-Z_0-9] \s 空白符号 [/t/n/x0B/f/r] \S 非空白符号 [^/t/n/x0B/f/r]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Scala 入门基础(包)]]></title>
      <url>%2F2015%2F10%2F27%2FScala-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80-%E5%8C%85%2F</url>
      <content type="text"><![CDATA[包是用来管理名称的,包括该名称的声明、定义等* Scala通过不同的包能使用很多类型的表达式,而包的引入在Scala中相当灵活 * 能给已有的包增加名称,或者创建新的包 * 包是能互相嵌套的如:scala.collection.mutable的结构如下 package scala { package collection { package mutable {......} } } * 包声明链scala.collection.mutable并不使scala与scala.collection可见 * 包声明链亦不对包含的包进行声明 即声明scala.collection并不意味着声明scala.collection.mutable 包的引入* 直接使用 val Y = scala.collection.mutable.Map（(a1,b1),(a2,b2),(a3,b3)） * import import scala.collection.mutable.ArrayBuffer var C = new ArrayBuffer[T]() //空数组缓存,数组元素长度为0 * import 全部引入 import scala.collection._ * 脚本前引入 * 具体使用处引入 * 包的引入有作用范围,和函数跟声明的作用范围一致 引入同一个包中的几个成员import scala.collection.{A,B} 当需要引入不同的包中同名的成员时,需要重命名之或隐藏之import scala.collection.mutable._ import java.util.{ HashMap =&gt; JavaHashMap } OR import java.util.{ HashMap =&gt; _, _} Scala默认引入以下三个包import java.lang._ import scala._ import Predef._ 作用范围* {......}号之间声明的量只有在{}内是有意义的 * {val a=0... {...val b=a}...} 内层能调用外层声明的量 * {val a=b...{val b=0...}...} 外层不能调用内层声明的量 * 内层声明与外层声明相同时,内层使用的是内层的声明,外层使用的是外层的声明 * 包的引入声明的量的作用范围是一致的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Scala 入门基础(元组)]]></title>
      <url>%2F2015%2F10%2F26%2FScala-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80-%E5%85%83%E7%BB%84%2F</url>
      <content type="text"><![CDATA[映射是二元的元组,元组是不同类型的值的聚集* 若干个单个的值包含在圆括号便构成元组 val g=(1 , 1.2,‘A’) //(Int,Double,Char)类型的元组 * 利用方法_1、_2、_3访问元组的组元 val h=g._1 或 val h=g _1 * 元组把多个值捆绑在一起,使他们能同时被处理 * zip方法能把几个集合结合起来 val one=Array(‘a’,‘b’,‘c’) val two=Array(1,2,3) val three=one.zip(two)或 val three=one zip two //对应的就生成一个元素是二元的数组,three:Array[(Char,Int)] = Array[(a,1),(b,2),(c,3)] val four=one.zip(two).toMap 或 val four = one zip two toMap //对应的生成一个以数组one为键,数组two为值的映射,four: scala.collection.immutable.Map[Char,Int] = Map(a -&gt; 1, b -&gt; 2, c -&gt; 3)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Scala 入门基础(映射)]]></title>
      <url>%2F2015%2F10%2F26%2FScala-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80-%E6%98%A0%E5%B0%84%2F</url>
      <content type="text"><![CDATA[映射是包含一组键值对应元素的集合不可变映射val Z = Map（a1-&gt;b1,a2-&gt;b2,a3-&gt;b3） val Z = Map（(a1,b1),(a2,b2),(a3,b3)） //an为键 bn为值 ,an互不相同 bn可以相同 可变映射val Y = scala.collection.mutable.Map（(a1,b1),(a2,b2),(a3,b3)） val X = new scala.collection.mutable.Map[T1,T2] 获取值val a = Z(an) val b = Z.get(an) //当映射中不包含对应的键时,抛出异常 val c = Z.contains(an) //boolean val d = Z.getOrElse(an,0)//有an就返回an，否则返回0 值更新Y(an) = bn Y += (a4-&gt;b4,a5-&gt;b5) Y -= a4 不可变映射–&gt;可变映射可以通过构造新的映射来增删其键值 val W = Z + (a4-&gt;b4,a5-&gt;b5) val V = W - (a4-&gt;b4,a5-&gt;b5) 枚举for（(i,j) &lt;- Z） E(i,j) for（(i,j) &lt;- Z） yield(j,i) //互换键值 获取映射内键的集合或值的集合 val e=Z.keySet val f=Z.values 可以利用for表达式只枚举映射的键或者集合]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Scala 入门基础(数组)]]></title>
      <url>%2F2015%2F10%2F26%2FScala-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80-%E6%95%B0%E7%BB%84%2F</url>
      <content type="text"><![CDATA[定长数组 12345678val A = new Array[T](N)val A = newe Array[Int](10)1.数组声明时若不给出值,会被初始化（Int为0，String为Null）Val B = Array(N1,N2)2.如果初始化,类型推断,可以不用声明数组类型、长度A(n) = Nn (数组赋值)val G = B + Array(1,2)val G = B - Array(1,2) 变长数组 1234567891011121314import scala.collection.mutable.ArrayBuffervar C = new ArrayBuffer[T]() //空数组缓存,数组元素长度为0C += e1 //C:ArrayBuffer(e1) //在数组尾部增加一个类型为T的元素e1C += (e2,e3)//C:ArrayBuffer(e1,e2,e3)C ++= Array(e2,e3)//C:ArrayBuffer(e1,e2,e3,e2,e3)C.trimEnd(1)//C:ArrayBuffer(e1,e2,e3,e2),移除最后一个元素C.insert(2,e3) //C:ArrayBuffer(e1,e2,e3,e3,e2),第二个元素后后插入e3C.insert(2,e1,e2,e3) //C:ArrayBuffer(e1,e2,e1,e2,e3,e3,e3,e2),第二个元素后后插入e1,e2,e3C.remove(3) //C:ArrayBuffer(e1,e2,e1,e3,e3,e3,e2),移除第三个元素后的一个元素C.remove(3,2) //C:ArrayBuffer(e1,e2,e1,e3,e2),移除第三个元素后的两个元素D = C.toArray //把变长数组C转为定长数组DE = A.toBuffer //把定长数组A转为变长数组E 遍历数组 123456789for(i &lt;- C)print(i)for(i &lt;- 0 to (C.length-1))println(C(i))注意：for(i &lt;- 0 to (C.length,2) ) println(C(i)) //每两个元素一条进行遍历for(i &lt;- (0 to C.length).reverse)println(C(i)) //倒叙遍历通过for语句枚举数组成员,可以实现多种数组控制,如把数组成员各加1并生成新数 组:val NEW=for(i &lt;- C) yield i+1 这种数组生成是对应原数组类型的(定长/变长)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2015%2F10%2F25%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Scala 入门基础(控制结构)]]></title>
      <url>%2F2015%2F10%2F24%2FScala-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84%2F</url>
      <content type="text"><![CDATA[if else 123456789if(A) B else Cdef min(x:Int,y:Int):Int=&#123; var a=x if(x&gt;y) a=y return a &#125;def min(x:Int,y:Int)= if(x&gt;y) y else x while 12345while(A) Bdo B while(A)值得注意的是,while同do语句不 产生值,为了让循环发挥作用, while要不更新var,要不执行I/O for 123456789101112131415161718192021222324252627282930313233343536373839for(i &lt;- e) E(i)//发生器(i &lt;- e),函数体E(i)//1 to 4 (1=&lt;i&lt;=4);//1 until 4 (1=&lt;i&lt;=4-1)(不包含上界)for(i &lt;- 1 to 4) println(“No.”+ i) 在for语句中使用if语句进行过滤for(i &lt;- e) if(A) E(i)for(i &lt;- 1 to 4) if(i%2==0) if(i!=2) //if(i%2==0&amp;&amp;i!=2) println(“No.”+ i)能把if语句写入循环体,而非函数体中,此时要使用“;”间隔 for(i &lt;- 1 to 4;if i%2==0;if i!=2) println(“No.”+i)for语句实现嵌套枚举只需要多加一个&lt;-字句for(i &lt;- 𝑒 )for(j &lt;- 𝑒 )E(i,j)for(i &lt;- 𝑒 ;j &lt;- 𝑒 )E(i,j)for(i &lt;- 𝑒 ;if A;j &lt;- 𝑒 ;if B)E(i,j)嵌套枚举并非是同时进行的枚举;形如for(i &lt;- 1 to 4;j &lt;- 1 to 2),其枚举形式是,先 枚举i = 1,再完整枚举j = 1,j = 2;然后是枚举i =2,再完整枚举j = 1,j =2for语句除了对枚举值进行操作并释放该值外,可以用以赋值,即把每一次枚举的值记 录在集合中.for(i &lt;- e) yield E(i)若E(i)由花括号括起,yield须在花括号外,即for(i &lt;- e) yield &#123;E(i)&#125;val No=for(i &lt;- 1 to 4) yield iyield保留字返回的类型跟for循环体第一个&lt;-语句的集合类型相同,如非集合时,返回 的是序列for(i &lt;- “HELLO”)yield ifor(i &lt;- 1 to 2)yield i.toCharfor(i &lt;- “HELLO”;j &lt;- 1 to 2) yield (i+j).toChar for(i &lt;- 1 to 2;j &lt;- “HELLO”) yield (i+j).toChar 分别返回什么结果呢?String:HELLOVector&lt;?,?&gt;String:IJFGMNMNPQVector&lt;I,J,F,G,M,N,M,N,P,Q&gt; match 123456789101112a match&#123; case e1 =&gt; E1 case e2 =&gt; E2 ... ...&#125;//a可以是数组、任意类型等,E可以是对应的值、常量、变量、类型等。//val sign = a match&#123;...&#125; match表达式能用以直接赋值//匹配是从上而下的//匹配语句case后接 _ 代表的是任意,一般在最后的case语句中这么写,即匹配不到上 面的值时,执行如 a match &#123;case e1 =&gt;... case e2 =&gt;... case _ =&gt;....&#125;//匹配语句返回的值有多种类型时,Scala不能执行类型推断,并且只会返回Any类型如 val final=a match &#123;case e1 =&gt; “HI” case e2 =&gt; ‘H’ case e3 =&gt; 123 &#125; try catch 123456789* Scala处理异常一般通过throw抛出一个异常并中止* 要么捕获并处理该异常,要么简单中止之* 异常抛出:throw new IllegalArgumentException * 异常捕获与处理:try&#123;函数体&#125; catch&#123;case...;case...&#125; * 异常捕获并中止:try&#123;函数体&#125; finally&#123;A.close()&#125;* try&#123;函数体&#125; catch&#123;case...;case...&#125; finally&#123;A.close()&#125;* throw、try-catch-finally表达式都能生成值* 如:throw new IllegalArgumentException(“Error!”) * def f():Int=try&#123;1&#125; finally&#123;2&#125; 输入、输出 123456输出：println(“A”) println(“A”+1)输出：输入通常使用read函数,如readLine是从控制台读取一行输入,指定类型时为readT ,T是所要指定的类型,如readInt等val name=readLine(“Your name :\n”) readLine带一个参数作为提示字符串val age=readInt() 其他语句 1234* return 语句表示返回某个值,但是Scala事实上无须使用return语句* 对于函数来说,其默认返回值是最后出现的一个值,不用特别注明。如需要返回的值并非最后出现时,可在函数体后加上该值的标识符使之“出现”* 声明函数时使用return语句,必须声明返回值的类型,如def abd():T=&#123;return&#125;* break/continue在C++中非常常见的控制结构语句,但在Scala中是不必要的,可以 使用布尔值类型的量通过IF语句进行控制]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IDEA MAC 快捷键]]></title>
      <url>%2F2015%2F10%2F23%2FIDEA-MAC-%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
      <content type="text"><![CDATA[Set | Get* ctrl+enter 出现生成get,set方法的界面 替换* command+R 替换 * ctrl+shift+R 可以在整个工程或着某个目录下面替换变量 行操作* shift+enter 换到下一行 * command+Delete 删除行 * command+D 复制一行 * command+X 剪切删除行 * ctrl+shift+J 把多行连接成一行，会去掉空格的行 * command+shift+上下箭头 把代码上移或着下移 自动生成代码* command+J 可以生成一些自动代码，比如for循环 导包* alt+enter 导入包，自动修改 格式化* command+alt+L 格式化代码 * command+alt+I 自动缩进 代码补全* ctrl+shift+space 代码补全，这个会判断可能用到的，这个代码补全和代码提示是不一样的 try | if | else* command+alt+T 把选中的代码放在 TRY{} IF{} ELSE{} 里 查找* alt+f7 查找在哪里使用 * command+alt+f7 查找选中的字符在工程中出现的地方 * command＋F7 可以查询当前元素在当前文件中的引用，然后按F3可以选择 ，功能基本同上 * command+shift+F7 先选中文本,高亮显示所有该文本，按Esc高亮消失。 * Alt+F3 先选中文本,逐个往下查找相同文本，并高亮显示。shift+f3就是往上找 * command+N 查找类 * command+shift+N 查找文件 * command+B 查找变量来源 * ctrl+shift+B 查找变量所属的类 * command+G 定位 * command+F 在当前文件里查找文本 f3向下看，shift+f3向上看 * ctrl+shift+F 可以在整个工程或着某个目录下面查找变量 相当于eclipse里的ctrl+H * alt+shift+C 最近修改的文件 * command+E 最近打开的文件 debug* f8 跳到下一步 * alt+f8 debug时选中查看值 * shift+f8 跳到下一个断点，也相当于eclipse的f7跳出函数 * f7 进入到代码 * alt+shift+f7 这个是强制进入代码 * ctrl+shift+f9 debug运行java类 * ctrl+shift+f10 正常运行java类 * command+f2 停止运行 大小写转行* command+shift+U 大小写转换 注释* command+/ // * ctrl+shift+/ /*...*/ 返回上次编辑位置* command+alt+左右箭头 返回上次编辑的位置 文件重命名* shift+f6 重命名 其他* command+P 方法参数提示 * command+shift+V 可以复制多个文本 * alt+f1 查找文件所在目录位置 * command+[或] 可以跳到大括号的开头结尾 * command+f12 可以显示当前文件的结构 * command+alt+B 可以导航到一个抽象方法的实现代码 * command+shift+* 列编辑]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[blog-look-look]]></title>
      <url>%2F2012%2F08%2F08%2Fblog%2F</url>
      <content type="text"><![CDATA[blog-look-lookhttp://www.oschina.net/news/75712我的手机 09:23:18http://www.oschina.net/news/75710/hasor-2-4-0我的手机 09:23:18https://github.com/vhf/free-programming-books/blob/master/free-programming-books-zh.md我的手机 09:23:18https://github.com/sindresorhus/awesome我的手机 09:23:18https://github.com/tiimgreen/github-cheat-sheet/我的手机 09:23:18https://github.com/GeniusVJR/LearningNotes]]></content>
    </entry>

    
  
  
</search>
